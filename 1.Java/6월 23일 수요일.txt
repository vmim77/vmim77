6월 23일 수요일
(오전)

*configuration 환경설정

오늘의 내용 : 스위치문, 반복문

★ 동일 패키지 안에 있는 어떤 클래스를 쓰겠다 하면, import를 안하면 자동적으로 자기 패키지에 있는 것을 쓰겟다는 것으로 인식한다.

★ Sungjuk이 day03에도 있고 day05에도 있는데, 
★ day05에서 MainSungjuk이 import를 안하고 Sungjuk을 부르면 day05에 있는 것이 와진다.
>> 나중에 접근제한자를 배우면 관리할 수 있다.

* 예약어(for, true, math)는 패키지명으로 못 쓴다.

==============================================================

[스위치문]
Unreachable code = dead code

★ if문은 비교연산자( >, <)가 되는데, switch문은 비교연산자를 못한다.
★ 항상 비교대상과 case value가 같냐, 같지않냐만 볼 수 있다.

==============================================================

[반복문]
for(int i=0; i<10; i++) << 10번 반복

i는 0부터 시작하기 때문에, 0 1 2 3 4 5 6 7 8 9 이렇게 10번 반복한다.

for문 안에도 if문을 넣을 수 있다.
*if 다음에 하고 싶은게 한 줄이면 중괄호 생략 가능하다.
*else문의 생략 : 조건이 거짓인 경우 특별한 처리를 원하지 않는 경우 else문은 생략​할 수 있다.
 
★★★★★ 꼭 암기하세요! ★★★★★
전위증감연산자(++a; --b;)는 맨 먼저 변수의 값을 1씩 증감을 마친 이후에 다른 연산을 한다.
후위증감연산자(a++;, b--;)는 다른 연산을 다 마친 이후에 변수의 값을 1씩 증감한다.
* n = n+ 1 은 n++과 같은말

*우리가 해야할 연산이 2개 이상이면 전위, 후위를 따진다. 증감식에는 --i나 i--는 상관없다 얘 혼자여서

반복문에도 break가 있다.
==============================================================

[계산기 개선하기]

cal3 => 사칙연산 유효성 검사 추가
cal4 => 첫번째정수, 두번째정수, 사칙연산자 유효성 검사 추가

>> try&catch로 오류발생시 프로그램 종료가 아니라 알맞은 값을 넣을때까지 계속 반복시키게 만든다.
>> for문의 중괄호에 갇힌 변수가 지역변수가 되주니깐 밖으로 빼준다.
>> 무한반복이면 for 밖으로 나가질 못해서 다음 코드가 실행되지 못하니 적절하게 break를 잡아준다.
==============================================================

(오후)

[반복문 합계]

for ( 초기화, 조건식, 증감식)
초기화 부분에서는 그냥 변수선언이 아닌 변수 선언하면서 초기화 형식으로 해줘야한다.
num1 (x), i = num1(o)


Sum6Main에서 리팩토링으로 정수 입력 부분 두 개를 하나로 합치면 첫 번째는 제대로 쳤어도 두 번째에서 이상하게 치면 다시 처음부터 쳐야하지만, 두 개를 따로 두면 오류가 난 곳만 다시치게 할 수 있다.

리팩토링으로 간결하게 하느냐? vs 오류난 곳부터 다시 입력할 수 있게 하느냐?

==============================================================

[회원가입 메소드 만들기]

== field ==
1) 아이디
2) 패스워드 (비밀번호 정책은 8글자 이상 15글자 이하에서 영문자, 숫자, 특수기호가 혼합되어져야 한다.)
3) 회원명

★★★★★ 메소드에 매개변수를 선언했다면 메인클래스에서는 매개변수와 동일한 자료형의 데이터를 전달하여야 한다.

▶ 비밀번호 정책에 맞는지 틀리는지 검사해주는 메소드

[작동순서]
1. 아이디
2. 비밀번호
2-1 글자갯수 파악
2-1 알파벳 보유 여부
2-2 숫자 보유여부
2-3 특수문자 보유여부

비밀번호정책은 8글자 이상 15글자 이하에서 영문자,숫자,특수기호가 혼합되어야 함

경우의 수는 '조건에 맞게 만들었다' & '조건에 맞지 않게 만들었다' 이므로 boolean 메소드로 선언

// 들어올 수 있는 입력값 예시 : "aB34$", null, "aBcdef34$123123", "qwer1234$"
// 일단 글자 길이부터 체크한다.

★★★★★ boolean 타입의 기본값은 false이다.

1. if(pwd != null)

먼저 null을 없앤다.
▶ pwd.length(); 는 글자길이를 세준다.
▶ 허나 바로 pwd.length();를 쓰면 안 된다. 왜냐하면 null값이 들어가면 NullPointException이 뜰 수 있기 때문이다.

2. int len = pwd.length();

null값이 아닌 비밀번호들을 받아서 숫자를 센 값을 len 변수에 넣어준다.

3. if(8 <= len && len <= 15)

그 다음 비밀번호 정책인 8글자 이상 15글자 이하에 맞는지 조건식으로 넣어준다.

4. 비밀번호 정책에 맞는다면 다음으로는 영문자, 숫자, 특수기호가 혼합되었는지 체크한다.

CharAt(인덱스값); 을 이용하여서 글자를 하나하나 뽑아내서 영문, 숫자, 기호가 맞는지 아닌지를 확인하는 반복문을 만든다.

5. for(int i=0; i<len; i++)

*CharAt은 결과값을 char 형태로 넘겨준다.

인덱스는 0부터 시작하니 시작값을 0으로 준다.

ex. 만약 9글자짜리 비밀번호인 "qwer1234$"가 들어온다면
"qwer1234$".charAt(0) ==> 'q'
"qwer1234$".charAt(1) ==> 'w'
"qwer1234$".charAt(2) ==> 'e'
"qwer1234$".charAt(8) ==> '$'

이 값들을 하나하나 char ch = pwd.CharAt(i);로 만들어서 한글자 한글자를 검색한다.

6. Wrapper 클래스 Character의 영문 판별 기능 Character.isAlphabetic

>> 소문자든 대문자든 알파벳이면 true를 넘겨준다.
>> 허나 int형 매개변수가 들어와야 하므로 (ch+0)으로 넣어준다.
★ int보다 작은 byte, short, char는 사칙연산을 만나면 자동으로 int형으로 변환된다.

영문이 들어왔다면 flagAlphabet 변수를 위에서 하나 선언해서 영문이 들어왔음을 표시해준다.
>> flagAlphabet=true;

7. 숫자 판단하기 Character.isDigit(ch)
숫자도 들어왔다면 flagNum=true;

8. 영문도 숫자도 아닌데 문자가 남아있다면 특수문자이므로 flagSpecial=true;를 else 절에 넣어준다.

9. if(flagAlphabet && flagNum && flagSpecial)를 마지막으로 넣어서 

영문도 true, 숫자도 true, 특문도 true가 되면 result를 true로 넘겨준다.

그러면 앞서 boolean isCheckPwd(String pwd) 메소드는 true의 결과값을 반환받는다.

10. for 무한반복을 이용해서 만든 비밀번호를 입력받는 곳으로 넘어가서 isCheckPwd(pwd) 메소드 자체는 true값을 가지고 있기 때문에

this.pwd = pwd; // 지역변수 pwd에 입력되어진 비밀번호는 필드 pwd에 넘어가고
break;로 무한반복문이 끝난다.

★★★★★

메인클래스는 간결하게 미리 만들어진 메소드를 호출만 할 뿐 프로그래밍은 일반클래스에서 다 짜는 것이다.

(팀원들끼리 분담하여 A는 회원가입 메소드를 가진 일반클래스를 만들고, B는 제품용 일반클래스, C는 주문용 일반클래스를 만들어서 서로가 한 걸 모은게 메인메소드이다.)

★★★★★