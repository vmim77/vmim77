07월 07일 오전수업

[인터페이스 정리]

** 구직자, 구인회사 클래스는 필드가 필요하고, 컨트롤러 클래스는 행위나 기능이니 메소드가 주로 있다.
** 초보자들은 메소드의 이름과 리턴타입, 파라미터를 어떻게 해야할지 모르니 가이드 라인을 준다.
** 그게 바로 '인터페이스'이다.
** 주로 사수들이 이렇게 만들면 된다고 '가이드라인'을 만들어준다.
** 쉽게 생각하면 '목차'이고, 이 목차를 Override를 한 것이 실제 메소드이다.

** open declaration은 정의를 보러가고 ==> '인터페이스'
** open implementation은 실제 구현한 것을 보러간다 ==> '클래스의 메소드'

** 메소드들은 인터페이스를 만든 다음에 그것을 구현한 클래스가 있다.
** 인터페이스가 없어도 괜찮지만, 목차가 없는 내용물만 있기 때문에 일목요연하게 보기 힘들다.

======================================================================


[블락 block]

클래스의 구동순서 

1. 필드
2. static 초기화 블럭
3. 자식클래스의 생성자 내의 부모클래스의 기본생성자
4. instance 초기화 블럭
5. 자식클래스의 생성자

개인 컴퓨터에 데이터들을 모아 놓지 않고, 따로 데이터들을 모아 놓는 곳이 있다.
데이터들이 모여있는 곳을 '데이터베이스'라고 한다. 그런 데이터베이스를 운용하기 위해서 가장 많이 쓰이는 프로그램은 'Oracle'이 있고, MS SQL Server, MySQL 등 많이 있다.

// 자바와 오라클 데이터베이스서버(원격지 서버) 간에 연결과 같은 환경설정시 사용된다.

// static 초기화 블럭에는 오로지 static 변수만 들어올 수 있고,
// 인스턴스 변수는 들어올 수 없다.
>> 객체를 만들어야 인스턴스 변수를 사용할 수 있기 때문이다.
>> 생성자가 나와야 객체가 생성된 것이니, 그 이후에 인스턴스 변수 초기화 가능

스태틱 초기화 블럭은 프로그램 구동 시 딱 1번만 작동한다.

필드 생성 => 스태틱초기화블럭의 메세지 출력 및 count++; => 부모클래스의 생성자에 있는 메세지 출력 => 인스턴스초기화블럭 메세지 출력 => 자식클래스 생성자 메세지 출력 =>  Main 메소드의 메세지 출력

name : 필드에서 '홍길동' 부여 => 인스턴스초기화 블럭에서 '서강준' 부여 => 자식클래스 생성자에서 '한지민' 부여

*** Child 클래스의 'static 초기화 블럭' 호출됨. ***
>> 부모클래스인 Parent 클래스의 기본생성자 호출함 <<
### Child 클래스의 'instance 초기화 블럭' 호출됨. ###
>> 자식클래스인 Child 클래스의 기본생성자 호출함. <<

★ 필드 => 스태틱초기화블럭(1번만) => 부모클래스생성자 => 인스턴스초기화블럭 => 자식클래스생성자

======================================================================

[Exception]
1. ArrayIndexOutOfBoundException
==> 배열의 크기가 오버가 되어지면 발생하는 익셉션

** e.getMessage(); 은 오류메시지를 알려주는 것이다.
** e.printStackTrace(); 은 오류메시지와 함께 어디가 오류인지를 추적해서 알려준다.

-------------------------------------------------------------------------------------------------------------------------------

2. ArithmeticException
==> 분모에 0 이 들어가는 경우에 발생하는 익셉션

try & catch는 오류가 발생시 catch의 명령을 시행 후 끝내버린다. 
허나, 오류시 명령 출력 후에도 계속해서 돌아가게 하고 싶다면 for를 try&catch의 바깥으로 뺀다.

★ 여러 개의 오류를 잡으려면 catch를 여러 개 쓰면 된다. 
★ catch는 여러 개 쓸 수 있다.

(ex.1)
catch (ArrayIndexOutOfBoundsException e) {
	System.out.println(">> 배열의 인덱스 범위가 초과 되었습니다. ");
} catch (ArithmeticException e) {
	System.out.println(">> 분모에는 0이 올 수 없습니다. <<\n");
}

(ex.2)
catch (ArrayIndexOutOfBoundsException | ArithmeticException e) 이렇게 쓸 수도 있다. JDK 7부터 가능!!
버티컬라인(|)은 한 개만 써야한다.

-------------------------------------------------------------------------------------------------------------------------------

3. Exception들의 최상위 부모

Exception은 최상위 부모클래스여서 모든 Exception 들을 받아서 처리한다.
굳이 catch에 특정 Exception을 쓰는 것보다는 그냥 Exception로 모두 받아서 처리하게 하는 것이 편하다.

* 허나 catch 처리를 할 때, 맨 위에 Exception e를 쓰면 위에서 다 잡아버려서,아래에는 도달을 할 수 없기에 아래에있는 특정 Exception들은 Unreachable 오류가 뜬다.
★ 그래서 순서는 작은것부터 쓰고 큰 것(최상위 부모 Exception)을 맨 뒤에 둬야한다.

컴파일 오류는 자바 문법에 오류가 발생한 경우임. 실행자체가 아예 안 된다.
실행 오류는 실행시 데이터값 자체에서 오류가 발생한 경우임. 실행은 된다.

부모가 자식을 받을 순 있지만, 자식이 부모를 받을 수 없다.

-------------------------------------------------------------------------------------------------------------------------------

[try finally]

오류가 발생하든 발생하지 않든 finally 중괄호 안의 명령은 무조건 실행한다.

오류를 잡을 수 있는 catch가 없어도, 무조건 finally 안에 명령은 실행하고 끝난다.

======================================================================

[사용자 정의 Exception]

자바에서 보면 오류가 아닌데, 사용자가 정의한 Exception

======================================================================

[Exception throws]

메소드 정의한 곳에서 Exception 처리하는게 당연하지만, 처리를 호출한 쪽으로 돌려버리는 것

이렇게하면 개발자말고, 사용자가 에러메시지를 정의하는 것이다.

======================================================================


07월 07일 오후수업

[무명클래스 == 익명클래스 == annonymous class]

인터페이스 변수 : public final 생략
인터페이스 메소드 : public abstract 생략

인터페이스가 추상클래스보다 추상이 더 높다.
인터페이스는 모든 메소드가 다 추상이고, 추상클래스는 최소 1개  

인터페이스 또한 미완성이기 때문에, 인스턴스 선언이 불가능하다.
허나, 저장시키는 용도인 배열선언은 가능하다.


무명클래스는 이름은 없으나, 만들자마자 객체화를 해야한다.
{

@Override
public double area(double x, double y) {	
	return x*y*0.5;	
};

이 만큼이 원래는 클래스에 들어갈 내용이다.

무명클래스는 '클래스정의 + 객체화' 이다.
객체화하려 new를 하고, 클래스 이름의 자리에는 이름이 없기 때문에 형식을 따라 가려고 InterArea라는 인터페이스 이름을 적은 것이다.
>> 그 이름에 인터페이스에 정의내려진 메소드를 재정의하려고 무명클래스를 만든 것이다.

무명클래스는 선언한 클래스에서만 사용할 수 있고, 다른 클래스에서는 재활용 못한다.

그 전까지는 삼각형 클래스, 사각형 클래스, 타원형 클래스 들을 따로따로 만들었는데, 무명클래스는 1회용으로 바로 클래스 안에서 만들어서 사용한 것이다.

★ 무명클래스는 항상 인터페이스를 사용해야 한다.

인터페이스를 구현한 클래스가 특정한 한 곳에서만 사용되면(다른 패키지의 클래스에서 안 쓰는 것) 굳이 클래스 파일로 만들 필요 없이 무명클래스를 사용하면 된다.

InterArea.java
Triangle.java
Rectangle.java
Circle.java

이렇게 다 만들고 Main에서만 쓸거면 굳이 클래스파일 만들 필요없이, Main 클래스 내에서 익명클래스로 작성해서 해도 된다.
>> 그냥 따로 클래스를 만들어서 켜놓고 만들어야 할 것을, 한 클래스 안에 쭉 쓴 것이다.

★ 무명클래스는 상속을 받을 수 없으니, 익명클래스는 추상클래스와 인터페이스로부터 만들 수 있다.
>> 익명클래스는 오로지 자바만 가지고 이벤트 처리할 때 주로 쓴다.

======================================================================

[람다]

'최대한 간단하게 쓰자는 것'이 주 목표이다.

람다에서 익명클래스가 쓰인다.
람다는 익명 함수(Anonymous functions)를 지칭하는 용어이다.

C언어 함수 = 자바 메소드

★ 자바는 메소드를 단독으로 사용할 수 없다. 항상 '객체.메소드' 식으로 쓴다.

람다식을 사용하기 위해서는 인터페이스 클래스명 위에 @FunctionalInterface라고 써야한다.(함수용 인터페이스로 만드는 것이다.)

★ 람다식을 사용할 함수용 인터페이스에는 추상메소드가 딱 1개만 있어야 한다.
어차피 메소드가 1개밖에 없으니, 메소드 이름을 알 필요가 없다(자바가 알아서 해준다.) 
파라미터만 쓰고 -> { }로 해서 내용물만 적으면 된다.

자바에서 람다식(Lambda)은 JDK 1.8 이후 부터 사용가능하다.    


원래 :
1. 오버라이딩 하는 클래스 파일 생성
2. 오버라이딩 메서드 작성
3. 해당 클래스의 객체 생성
4. 오버라이딩 메서드 호출

익명메소드 : 인터페이스 생성 -> 메인메소드에 추상메소드 구현용 클래스 생성과 동시에 객체화 -> 메인메소드에서 메소드 실행
** 언뜻보면 추상클래스나 인터페이스를 인스턴스화한것처럼 보인다.


람다식 : 익명클래스마저 더욱 간결하게 써버린 것이다.
** 대신 인터페이스는 메소드 1개만 있어야 한다.
======================================================================

[컬렉션]

Generate Constructor Using Fields - 파라미터가있는 생성자 만들기

★ 파라미터가 있는 생성자를 만들면 기본생성자가 삭제되니 수동으로 다시 만들어줘야 한다.

System.out.println("mbr1 : "+mbr1); 이렇게 치더라도 메모리 주소값 출력이 아니라 info( )처럼 나오고자 구현하려고 한다.

==> 모든 클래스들은 생략되어있지만, Object를 상속받고 있다.
==> 클래스들의 최상위 부모는 'Object'이다.

==> **mbr1와 mbr1.toStirng( )이 같다는 것을 이용해서, Object의 상속을 이용해 toString( )을 재정의해서 info( ) 메소드처럼 만든다.

** 원래는 객체명.toString으로 써야 메모리 주소를 보여주는데, 그냥 객체명만 적어도 메모리 주소 값을 보여준다.

그래서 Object의 메소드들도 개발자가 원하는 대로 재정의할 수 있다. (toString 등...)

-------------------------------------------------------------------------------------------------------------------------------

배열의 가장 큰 단점은 한 번 크기를 정하면, 내가 다시 바꿀 수 없다는 것이다.

배열의 default는 정수는 0, 실수는 0.0, char는 공백, String을 포함한 객체는 null이다.(Member 객체 타입이니 null이 초기값)

>> 사이트에서 회원가입 숫자를 함부로 정할 수 없다. 얼마나 회원가입할지 모르니깐, 그렇다고 배열 갯수를 무턱대고 크게하면 null값들이 나온다.

앞으로 어떤 객체를 저장할 장소로는 배열을 잘 안쓰고, 컬렉션을 쓴다.
>> 왜? 컬렉션은 크기가 무한대이다.

[Collection(자료구조)와 배열의 차이점]

★ 배열은 크기가 한정 되어져 있지만, 컬렉션은 크기가 무한정
★ 배열은 동일한 타입만 들어올 수 있지만, 컬렉션은 '객체'이기만 하면 어떤 것이든지 입력 가능하다.
==> String, Member, Gujikja, Company 등등 여러가지 객체들이 한꺼번에 다 들어간다.

[가장 많이 쓰는 Collection 타입]
List 계열, Map 계열
==> 웹에서는 이 두 계열만 써서, 두 개만 알면된다.
==> List를 구현한 클래스들 중에서 웹에서 가장 많이 쓰는 것은 'ArrayList'이다.
==> Map을 구현한 클래스들 중에서 웹에서 가장 많이 쓰는 것은 'HashMap'이다.

** ArrayList는 클래스, 그냥 List는 인터페이스이다.
>> 다형성으로 인하여, List(인터페이스)로도 객체를 받을 수 있다.


import java.util.*; << 유틸패키지에 있는 모든 것을 다 쓰겠다는 말이다.

[저장소에 추가하기]
★ arrList.add(Object e);

최상위 클래스인 Object에는 String이건, Member의 객체이든, Product의 객체이든 모두 다 넣어줄 수 있다. (다형성)


★ 배열의 길이는 배열명.length( )
★ 컬렉션의 길이는 컬렉션명.size( )

★ 배열에서 값 끄집어 오기는 Arr[i]
★ 컬렉션에서 값 끄집어 오기는 arrList.get(i);
==> 리턴타입은 Object
==> 타입들의 위치가 제각각이기 때문에, Object인 것이다. 


저장은 객체면 아무거나 넣을 수 있어서 편했지만, 꺼내올 때는 중구난방으로 넣었기 때문에 빨리 찾아오는데 시간이 좀 걸린다.

(ex. 폴더에서 .mp3만 뽑아와라) ==> 해결책은 폴더를 또 만들어서 나눠놓는다.
(ex2. List에서 String타입만 뽑아와라) 

그래서 해결책으로 배열처럼 넣는다고 한다.
=> 갯수는 무제한
=> Member만 받는 곳, String만 받는 곳, Produnct만 받는 곳으로 저장한다.
==>> 이를 해결하려고 제네릭을 쓴다.


★★★★★
Auto boxing, Auto Unboxing 다시보기

내일 : list 제네릭 ~