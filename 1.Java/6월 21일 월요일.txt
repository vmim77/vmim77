2021년 06월 21일 

*클래스만 대문자로 시작, 메소드, 변수는 소문자로 시작하자
*undefined : 정의가 안됐다.

(오전)
1. 생성자 : 필드를 초기화 시키는 게 주 목적
2. 구분자
3. 파라미터가 있고, 없는 메소드 만들기
4. casting(강제형변환)
5. 연산자

(오후)
1. 비교연산자
2. 스캐너 (nextLine, nextInt, nexDouble, next)
3. 스캐너 (try & catch - 오류값이 들어오면 잡아내기)
4. 스캐너 (Integer.parseInt -> string을 int타입으로 변환)


================================================
[생성자.Constructor]

자바에서 소괄호가 있는건 '메소드, 생성자' 둘 뿐이다.

생성자는 클래스 이름과 똑같다, return타입이 없다.
메소드는 return타입(void, String)이 있다.

객체를 만듬과 동시에 필드에 값들을 주고 싶다면, 
Member eomjhMbr = new Member("eomjh","qwer1234","엄정화", 35, 100);
이러한 생성자를 사용하면 된다.

그러면 Main 클래스에서 
Member lssMbr = new Member();
		lssMbr.userid = "leess";
		lssMbr.passwd = "abcd";
		lssMbr.name = "이순신";
		lssMbr.age = 25;
		lssMbr.point = 200;

이걸 안 쳐주고 바로바로 필드 초기화를 할 수 있다.

허나, 지역변수로 들어오기 때문에 멤버변수로 보내줘야 한다.
(*지역변수 이름과 멤버변수 이름이 같으면 우선순위는 지역변수이다.)

★기본생성자도 쓰고 싶고 파라미터가 있는 생성자도 쓰고 싶다면, 기본생성자를 직접 선언해줘야 한다.
>> 나중에 JSP에서도 기본생성자를 꼭 써줘야 함.
================================================
[구분자]
클래스나 변수를 대신 부를 수 있는 '대명사'가 있다. 그것을 '구분자'라고 부른다. 

this.userid = userid;
>> this는 객체, 'Member.class'를 대신 부르는 것이다.
================================================
[회원정보 변경 메소드 만들기]

메소드 안에서 다른 메소드를 호출할 수 있다.
================================================
[casting]

작은 것이 큰 것에는 자동으로 형변화되서 그냥 들어갈 수 있지만, 큰 것이 작은 것에는 그냥 들어갈 수 없고 강제형변환(casting)을 해줘야 들어갈 수 있다.
(! 단 값의 데이터범위가 변수 내에 있어야 한다.)

종류가 같은 것끼리 크기를 비교할 수 있다. (실수와 정수는 byte크기를 비교 안한다. 실수가 정수보다 크기가 훨씬 크다.)

ex. float는 4byte이지만 long보다는 크다. (실수형이여서)
================================================
[연산자]
산술연산자 : + - * / %(나머지)
★★★★★// !!! 꼭 암기하세요 !!! //
// 후위증감연산자(a++; b--;) 는 다른 연산을 다 마친 이후에 1씩 증감한다. 
// 전위증감연산자(++a; --b;) 는 맨먼저 1씩 증감을 마친 이후에 다른 연산을 한다.

ex. i > ++j
++j; => i>j 
전위는 내 값에 먼저 +1, 그 후에 비교연산자

i>j++
i>j => j++;
후위는 먼저 비교연산자, 그 후에 내값에 +1


**대부분 &&, ||만 쓴다.
================================================
[스캐너]

정수와 실수는 공백도 종결자로 봐주며, 스캐너버퍼를 비우지 않아서 공백 뒤에 남아있는 찌꺼기들을 다음 스캐너에 보낼 수 있다. (띄어쓰기 안하고 바로 엔터만 쳐도 찌꺼기가 남아져있다.)
그래서 정수형 스캐너를 쓴 다음에 변수가 없는 sc.nextLine()만 써서 스캐너버퍼를 비워준다음에 다음 스캐너버퍼를 쓰면 정상적으로 쓸 수 있다.

★sc.nextInt();나 sc.nextDouble(); 중간에 sc.nextLine();를 써서 스캐너버퍼를 비워주는 습관이 필수다.
★sc.nextInt(), sc.nextDouble();, sc.next(); 3개 모두 sc.nextLine();로 비워줘야 함.
>> 위의 3개는 모두 종결자가 '엔터와 공백'이다.
(★ sc.nextLine();빼고는 모두 다 비워주자.)

		int num1 = sc.nextInt();
		sc.nextLine();
		 

이거 걍 셋트로 외우자

[스캐너 Integer.parseInt]
Integer.parseInt는 문자열이지만 내용은 정수인 것이 와야한다.
Double.parseDouble(str_num);은 문자열이지만 내용은 실수인 것을 실수로 바꿔준다.


정수는 실수에 포함되지만
실수는 정수에 포함되지 않는다.

String을 int나 double로 바꿀 때는 들어오는 값은 String뿐이라 
위에 지역변수 String str_num ="";을 줬지만,
 
int나 double을 String로 바꿀 때는 들어오는 값이 2가지라서 
데이터타입이 다르기에 공용 지역변수를 주지 않고, 
그냥 catch에 'InputMismatchException e'만 줘서 int나 double이 아닌 값이 들어온 곳을 찾아내게 만든다.

try 괄호 안에 scanner 인스턴스 선언과, sc.close();를 다 넣어도 상관없다.

근데 Scanner sc = new Scanner(System.in);를 메인메소드 괄호 안에 넣어 두는게 편하다. (지역변수 범위 신경 안써도 괜찮아서)

**내일 수업내용 : 스위치문, 반복문
**정답이 딱 정해져있지 않다, 경우의 수만 잘 따지면 프로그래밍은 쉽다.