07월 06일 오전수업

[다형성]

자식클래스로 생성되어진 객체를 부모 클래스 타입으로 받을 수 있다. (※ 이 저장소에는 저장되어진 형태가 다양하다.)
ex. aniArr[0] = new Dog( ); 
>>aniArr에는 Dog, Cat, Duck도 들어갈 수 있다.

[추상클래스 & 메소드]

추상(미완성) 메소드를 가지기 위해선, 클래스는 추상(미완성) 클래스가 되어야 한다.
abstract class, abstract void
추상클래스는 주로 부모클래스로 많이 쓰인다. 자체적으로 인스턴스 생성은 불가능하다.
하지만, 자식클래스의 인스턴스는  추상클래스(부모클래스)로 받아줄 수 있다.

★ 추상클래스의 미완성 메소드는 반드시 자식클래스에서 미완성 메소드를 재정의를 해줘야한다. (@Override)
===========================================================
[구인구직프로그램에 다형성 추가하기]

Gujikja와 Company에는 showInfo 메소드가 있는데, 이것은 무조건 써야하는 것이니 강제화 시켜야 한다. ( Member에서 추상메소드로 만들어서, 반드시 자식클래스에서 재정의하도록 한다. )

원래 메소드라면 중괄호( { , } )가 나와야 하지만, 추상메소드는 중괄호가 없다.
ex. public abstract void showInfo( );

또한, 클래스명에도 abstract를 써줘야 한다. ( 클래스 안에 미완성메소드가 있다는 뜻이다. )
ex. public abstract class Member

Gujikja와 Company에 가서 showInfo( )위에 @Override를 써줘서 메소드의 오버라이딩임을 표시해준다.
>> 재정의를 할 땐, 부모클래스의 접근제한자보다 크던가, 같아야 한다.

----------------------------------------------------------------------------------------------
[구직자, 구인회사 회원가입 수정]

지금은 구직자 배열과 구인회사 배열이 따로 있는데 이것을 부모클래스인 Member의 배열을 만들어서 구직자 정보와 구인회사 정보를 모두 넣어준다.

★★★★★ 추상클래스는 인스턴스 선언은 불가능하지만, 저장장소를 만드는 것은 가능하다.

Gujikja와 Company에 만들어진 count 스태틱변수를 지우고, Member에 하나 만들어준다.
(Gujikja 객체 및 Company 객체의 개수를 알려는 용도)

>> count에는 접근제한자를 안줘서, 구직자와 회사에서 count를 지워도 상속을 받아서 Gujikja.count++ 이 틀렸다는 말이 안 나온다.

구직자 회원가입과 구인회사 회원가입의 파라미터에서 배열을 mbrArr로 바꾸면 메소드 오버로딩으로 만든 것이 구직자회원가입으로만 가지게 된다.

방법 1. 메소드 이름을 다르게 한다.
방법 2. 구분자를 해준다. (파라미터에 1이나 2를 추가한다.)
>> 메소드 이름을 다르게 하는 방법을 선택해서 수정할 것이다.

mbrArr[i].getId는 이제 회사와 사용자들 전체에서 아이디가 고유해야 한다.
그 전까지는 사용자 아이디들에서만 중복검사를 했고 구인회사 아이디들에서만 중복검사를 했는데, 이제는 합쳐진 것이다.

----------------------------------------------------------------------------------------------
[구직자, 구인회사 로그인 수정]

loginGu = mbrArr[i]; 는 MissMatch가 뜬다.
왜냐하면 mbrArr에는 구직자와 구인회사가 저장되니, 구직자만라고는 단정 지을 수 없기 때문이다.

loginGu는 Gujikja 타입이어서 mbrArr[i]가 구직자인지 구인회사인지 모르니 instance of 로 어떤 인스턴스인지 확인하고 강제형변환을 하여서 넣어준다.

'mbrArr[i] instanceof Gujikja' 이 자체는 boolean값을 반환해주니, 한 번 더 IF로 물어봐서  구직자 인스턴스가 맞다면 그때 loginGu에 넣는다.

login 메소드는 구직자와 구인회사 둘다 스캐너와 mbrArr을 파라미터로 두면, 메소드의 중복이라는 오류가 뜬다.
>> 메소드의 오버로딩이 파라미터가 같아져서, 리턴타입이 다르더라도 중복이 된다.
>> 해결하기 위해서는 sc, mbrArr의 위치를 바꾼다면 다시 메소드의 오버로딩이 된다.

구직자 : public Gujikja login(Scanner sc, Member[] mbrArr)
구인회사 : public Company login(Member[] mbrArr, Scanner sc)

>> 이렇게 단순히 파라미터의 순서만 바꿔도 메소드의 오버로딩이 된다.
>> 파라미터의 순서, 갯수, 타입이 다르면 메소드명이 같아도 다른 메소드로 친다.

저장소는 단순히 Member지만, 저장된 내용들은 Gujikja, Company의 인스턴스들이다.
----------------------------------------------------------------------------------------------
[모든 구직자, 구인회사 보기 수정]

파라미터를 mbrArr로 바꾸면, 둘 다 메소드명도 똑같고 파라미터도 똑같아져서 메소드의 오버로딩이 깨진다.
>> 메소드 명을 바꾸던지, 파라미터를 달리 해주던지(구분자 넣어서)
>> ctrl.showAllGujikja(mbrArr)로 하거나, ctrlshowAll(mbrArr, 1)로 하거나

showInfo를 Member에서 미완성메소드로 놨으니, 구직자 및 구인회사에서 재정의한 메소드를 각각 호출해준다. (instanceof로 구분해서)


------------------------------------------------------------------------------------------------
[연령대 검색 수정]

mbrArr[i]은 Gujikja 또는 Company인데, getAge( )는 Gujikja에만 있으니, instanceof로 구직자인 것을 확인해서 형변환해서 넘겨줘야 한다.

((Gujikja)mbrArr[i]).getAge()

근데 또 mbrArr[i]로 하면 5번을 다 돌면서 Gujikja나 Company 값을 다 가져올 수 있다.
그래서 instanceof 로 구직자인 것을 확인하고 꺼내와야 한다.

if( mbrArr[i] instanceof Gujikja && ((Gujikja)mbrArr[i]).getAge()/10*10 == ageline)

System.out.println(mbrArr[i].showInfo()); // 이미 위에 if절에서 Gujikja임을 확인했으니, 여기는 형변환 불필요

------------------------------------------------------------------------------------------------
[성별 검색 수정]

★ 저장되어진 저장소에는 Gujikja와 Company가 섞여서 5개가 있다. 꺼낸 것이 i번째에서 꺼낸게 실제로 Gujikja가 맞지만, mbrArr[i] 는 Member타입으로 받아온 것이여서 getJubun()은 Member에 없어서 쓸 수 없다고 나온다. 그래서 강제형변환으로 mbrArr[i]가 Gujikja임을 알게 해줘야 한다.

getJubun은 부모클래스 멤버에 없기 때문에 형변환을 해야하지만, showInfo는 멤버에 미완성메소드로 있고, 자식클래스에서 재정의를 해줬기 때문에 형변환이 불필요하다.
mbrArr[i] 들도 모두 Gujikja로 바껴서 if 절 안으로 들어가질 것이다.

>> ((Gujikja)mbrArr[i]).getJubun()
------------------------------------------------------------------------------------------------
[연령대 및 성별 검색 수정]

★ 부모타입 배열.자식에만있는 메소드이면, 부모타입 배열을 자식클래스로 형변환시켜줘야 한다.
((Gujikja)mbrArr[i]).getAge( )

부모의 배열에서 값을 꺼내오는 for문을 만든다면 반드시
if(mbrArr instanceof 자식클래스명) 으로 먼저 원하는 자식클래스를 거른 다음에, 아래에서 기능을 출력하도록 한다.
>> 만약 자식클래스에만 있는 메소드를 쓰고싶다면 mbrArr[i]를 강제형변환 시켜준다.

===========================================================
[final이란?]

* 생성자의 주 목적은 필드의 초기화이다.
부모에 있는 필드를 자식이 맘대로 변경 못하게 하고 싶을 때 쓴다.
해당필드에 들어간 변수값을 상수로 지정하고, 다시는 변경 못하게 한다.
ex. 
final String FIRSTNAME = "김";
FIRSTNAME = "이"; (X)

* final 변수를 상수변수 라고도 부른다.
>> 처음에 들어온 값이 끝이다. 변수값을 다시는 변경 못한다.

★ final 변수는 다른 변수들과 다르게 변수명을 전부 대문자로 해준다.(관행)
>> final String FIRSTNAME

------------------------------------------------------------------------------------------------
[final 메소드]

final void exam( )
위와 같이 쓴다면, 자식클래스에서는 오버라이딩(메소드 재정의)을 못한다.
------------------------------------------------------------------------------------------------
[final 클래스]

자신의 자식클래스에게 상속을 안해주겠다는 뜻이다.

public final class Father extends GrandFather



final 변수 : 변수 값 변경불가
final 메소드 : 메소드 재정의 불가
final 클래스 : 상속을 안해주겠단 뜻이다.
===========================================================
[인터페이스]

인터페이스는 오로지 미완성메소드로만 이루어진 것이다. 

미완성클래스는 적어도 1개 이상만 미완성메소드가 있는 것이다.
>> 완성메소드도 있다.

근데, 인터페이스는 정상적인 메소드는 아예없고, 전부 다 미완성메소드이다.

★ 인터페이스에서 필드를 만들면 public final이 생략되어져 있다.
==> 즉, public final double PI = 3.141592; 이다.

★ 인터페이스에서 메소드는 무조건 추상메소드(미완성메소드)로만 되어져야 한다.
==> 마찬가지로 메소드도 public abstract이 생략되어져 있다.
==> 즉, public abstract double area(double x, double y); 이다.

인터페이스를 상속 해오면, public class Triangle implements InterFigure 식으로 나온다.
==> Triangle 이라는 클래스는 InterFigure 라는 인터페이스를 implements(구현)한다는 말이다.
==> '미완성메소드를 재정의하겠다'는 뜻이다.

★ 인터페이스를 가져오는 클래스는 반드시 인터페이스에서 미완성된 메소드를 재정의하여야 한다.

삼각형 넓이 : 밑변 * 높이 * 0.5 = 넓이
사각형 넓이 : 가로 * 세로 = 넓이
타원 넓이: Pi * 장축 * 단축 // 원 넓이 : PI*r의 제곱
===========================================================

InterFigure 또한 부모클래스처럼 다형성이 적용된다.
Triangle tri = new Triangle(); 와 InterFigure inter1 = new Triangle(); 는 똑같다.
>> 실제 어떤 클래스의 객체를 만든 다음에, Interface로도 받을 수 있다.

★★★★★
// == 다형성(Polymorphism) == //
// ==> 자식클래스로 생성되어진 객체를 부모클래스의 타입으로 받을 수 가 있다.
// ==> 특정한 인터페이스로 구현된 클래스의 객체를 특정한 인터페이스의 타입으로 받을 수 가 있다. 
★★★★★

>> aniArr[0] = new Dog(); 
>> Triangle tri = new Triangle(); 와 InterFigure inter1 = new Triangle();
===========================================================

07월 06일 오후수업

[인터페이스]
x, y는 가변해야 하는데, 인터페이스에 주면 final로 들어가져서 여기에 둘 순 없고 부모클래스를 하나 만든다.

인터페이스도 쓰면서, 부모클래스의 상속도 받아야 한다면?

public abstract class 부모클래스 implements InterFigure

public class 자식클래스 extends 부모클래스
>> 이러면 상속도 받고, 메소드 재정의도 해야한다.

왜 이렇게 쓰는가?)
인터페이스 -> 부모클래스 -> 자식클래스

상수변수가 아닌 공통된 가변필드들이 있는데, 인터페이스에 쓰면 상수변수로 되니깐 부모클래스도 필요해서 

자식클래스들이 공통 필드도 있는데, 이렇게 쓰면 상속이랑 getter&setter를 이용하여 유효성검사도 하면서, 추상메소드도 쓸 수 있기 때문이다.


부모클래스가 인터페이스를 implements로 선언하면, 반드시 인터페이스의 추상메소드를 재정의 해줘야 한다.
허나, 부모클래스가 메소드재정의를 할 필요가 없이 자식들이 하면 되는데, 이러면 오류가 뜨니 미완성클래스임을 선언한다.
==> 이러면 부모클래스가 미완성클래스이니 자식클래스에서 오류가 난다.
==> 부모클래스가 인터페이스의 추상메소드를 재정의 안했으니, 자식클래스가 대신 해줘야 한다.

Triangle은 인터페이스의 메소드도 재정의도 해주면서, 부모클래스의 필드도 끌어다 쓸 수 있는 것이다.

인터페이스하고 점(.)하면 변수들은 다 상수여서 안 나온다.

★ 저장소는 인터페이스 타입이여도 상관없다


==========================================================
인스턴스 객체를 생성하면서 바로 필드를 초기화하고 계산하기


1번방법		interFigArr[0] = new Triangle(5, 4);
		interFigArr[0].area();
		==> Triangle.area();

2번방법		Triangle tri = new Triangle();
		tri.x = 5;
		tri.y = 4;
		tri.area()


파라미터가 있는 생성자를 이용하여 객체를 생성하면서 파라미터에 원하는 값을 넣으려면
1번방법을 쓰고,

기본생성자로 만들어서 하나하나 필드에 값을 넣어주려면 2번 방법을 쓰면 된다.

1. 각 클래스 별로 x, y 변수 선언하기
2. 부모클래스를 만들어서 x, y 변수를 만들어 상속받아서 하기
3. 파라미터 생성자를 이용하여 객체를 생성하는 동시에 부모클래스의 필드에 값을 넣어서 계산하기
------------------------------------------------------------------------------------------------

		// InterFigure[] interFigArr = new Figure[3];
		// 또는
		InterFigure[] interFigArr = new InterFigure[3];
		// 저장할 클래스는 부모클래스이건, 인터페이스이건 상관없다.

인터페이스의 추상메소드를 부모클래스 figure에 넘겨줌 

그래서 저장할 타입을 Figure로 하든 InterFigure로 하든 똑같은 말이다.
Figure에서는 메소드 재정의를 안해줬지만, 자식클래스들에게 넘겼으니 상관없다.


★★★★★
인터페이스는 상수변수와 추상메소드를 넘겨주고
부모클래스는 공통필드와 공통메소드(+추상메소드)를 넘겨주고
자식클래스는 받아와서 계산을 한다.
★★★★★

------------------------------------------------------------------------------------------------
인터페이스에는 x와 y 필드가 없고, 추상메소드만 있다.
필드 x와 y는 부모클래스 Figure에 있으니, instanceof (각각의 객체)로 해서 거른다음에 각각의 맞는 객체의 타입으로 casting을 시켜주면 된다.

if(interFigArr[i] instanceof Triangle) {
	str = "밑변이 "+((Triangle)interFigArr[i]).x+", 높이가 "+interFigArr[i].y+"인 삼각형의 넓이 => ";
}
else if(interFigArr[i] instanceof Rectangle) {
	str = "가로 "+((Rectangle)interFigArr[i]).x+" , 세로 "+((Triangle)interFigArr[i]).y+"인 사각형의 넓이 => ";
}
else if(interFigArr[i] instanceof Circle) {
	str = "장축 "+((Circle)interFigArr[i]).x+" , 단축 "+((Circle)interFigArr[i]).y+"인 사각형의 넓이 => ";
}


왜냐 필드x와 y는 부모클래스에 있다. (어차피 상속해주고 있으니깐)
그래서 형변환을 할 때 triangle을 하던, figure을 하던 똑같다

어차피 객체들이 생성하면서 파라미터있는 생성자로 부모클래스에 있는 필드에 값들을 넣어줬으니깐


★★★★★
		// == 다형성(Polymorphism) == //
		// ==> 자식클래스로 생성되어진 객체를 부모클래스의 타입으로 받을 수 가 있다.
		// ==> 특정한 인터페이스로 구현된 클래스의 객체를 특정한 인터페이스의 타입으로 받을 수 가 있다. 


★★★★★



★★★★★저장장소가 부모클래스, 인터페이스가 될 수 있다.

==========================================================
[인터페이스 다중상속]

★★★★★
자바에서
인터페이스는 여러 개의 인터페이스를 다중상속 받을 수 있다.
클래스는 여러 개의 클래스를 다중상속 받을 수 없다.
★★★★★

인터페이스는 상수변수, 미완성메소드 만드는 곳 !

여러개의 인터페이스(father, morther)를 상속받은 인터페이스(Me)를 구현하겠다고 한 클래스는 총 3개 인터페이스의 모든 메소드를 다 재정의 해야한다.

MeInpl은 Me라는 인터페이스를 구현(implements) 했다는 뜻의 제목이다.

저장장소 캐스팅
((InterMe)interfa).cook();

Interfa = work
Intermo = cook
InterMe = play + work + cook

자식에게 모두에게서 상속받은 메소드들이 모여있으니 자식으로 형변환시켜서 모두 사용할 수 있게 한다.

===========================================================

[구직자에 인터페이스 추가하기]

인터페이스는 상수변수밖에 못온다. (파이, 마라톤길이 등)

앞으로 추상메소드는 인터페이스에 쓴다.

Member 클래스는 딱히 인터페이스의 추상메소드를 재정의할 필요가 없기 때문에 추상클래스로 선언해서 자식클래스들이 메소드 재정의를 하도록 시킨다.


인터페이스로 만들어야할 메소드들의 가이드라인을 만들 수 있다.

인터페이스들에 가이드라인으로 잡아뒀던걸 implements를 하면 거기에 있는 것들을 모두 만들어야 오류가 없어진다.


자식클래스들은 인터페이스로도 받을 수 있고, 부모클래스로도 받을 수 있다(다형성)

항상 회사가면, 사수가 인터페이스로 된 가이드라인을 준다. 그러면 거기에 있는 모든 메소드들을 메소드재정의해야 집에간다.

나중에는 내가 사수가되면 인터페이스로 가이드라인을 만들어서 부사수한테 줘야 한다.

대신에 객체를 만들면 인터페이스로 받아줘야 한다.
InterGujikjaCompanyCtrl ctrl = new GujikjaCompanyCtrl(); 

한 인터페이스로 여러개의 클래스를 만들었다면 여러개를 교차해서 돌려서 검증할 수 있다.

메인메소드에서 바로
InterGujikjaCompanyCtrl ctrl = new GujikjaCompanyCtrl(); 
InterGujikjaCompanyCtrl ctrl = new GujikjaCompanyCtrl2();

식으로 이름만 바꿔서 돌려봐서 검사할 수 있다. 


내일 : 블락, Exception, 사용자가 만드는 Exception, 익명클래스, 람다표현식
