07월 05일 오전수업

프로젝트 : 도서프로그램 / 쇼핑몰 / 그룹웨어&LMS

[모든 구인회사 보기 & 내정보 변경하기 구현]
로그인을 했을 때만, 모든 구직자 보기 메뉴가 실행되게 할 예정 
로그인을 안 했다면 "로그인을 하세요"라고 메세지 출력



=======================================

1. 모든 구인회사 보기
GujikjaCompnayCtrl.class 

- 1. 경우의 수 : 구인회사가 아예 없을 수도 있다. 
- compArr == null 

* 오류메세지에서 항상 맨 위의 주소에 원인이 있다.


확장 for문에서는 배열의 길이만큼 돌기때문에 compArr[0]. compArr[1]에는 값이 있어서 제대로 작동하나, compArr[2]에는 값이 없어서 null이 출력되어 오류가 작동된다.

DecimalFormat df = new DecimalFormat("#,###");
금액 세자리마다 콤마찍기
=======================================

2. 내정보 변경하기
GujikjaCompnayCtrl.class

구직자 내정보 변경하기 : 암호, 성명, 희망급여만 바꿀 수 있게 구현한다.
>> 만약에 암호는 변경하기 싫다면, 그냥엔터만 치게해서 원래 암호를 쓰게 한다.

회원가입과 거의 유사하다.

비밀번호 정책에 가서 그냥엔터를 치면 원래 암호를 쓰게해주게 구현해야 한다.

★★★★★ 암호변경, 성명변경, 희망연봉변경 메모장으로 작동순서 확인해보기

회원가입은 구직자의 정보들을 입력받은 다음에 정보를 배열에 넣어준다.


★ loginGu = guArr[i]이다. 이미 로그인한 사람을 배열속에서 끄집어왔다.

>>로그인했다는 것 자체가 이미 배열에서 한 구직자를 선택해서 가져온 것이다.
>>굳이 변경되어진 정보를 다시 배열속에 넣을 필요가 없다.
loginGu.setPasswd(passwd) 이런 곳에서 이미 끄집어온 구직자에 정보를 새로 넣어주고 있으니깐
=======================================

[다중상속]

자바는 여러클래스를 다중상속하는게 불가능하다.
다만, C++은 가능하다.

=======================================

[protected 접근제한자]
눈에 안 보이지만 항상, public class child_1 extends object로 되어져있다.

object는 최상위클래스이다.

child_1의 부모는 Parent  ==> Parent의 부모는 object

protected는 다른 패키지에 있는 자식클래스도 쓸 수 있다.
child_2 ==> Parent



그외의 영역에서 public 필드 호출하는 법

=======================================




07월 05일 오후수업

[다형성]

다형성(Polymorphism) : 상속을 이용하여 여러 클래스 타입을 하나의 클래스 타입으로 다루는 기술 
(형태가 다양하다)

★★★★★ 자식클래스로 생성되어진 객체를 부모 클래스 타입으로 받을 수 있다는 것이 다형성이다.
Animal dog = new Dog(); (O) , aniArr[0] = new Dog(); (O)
Cat dog = new Dog(); (X)

★★★★★ 공통은 한 번만 하는 것이 가장 좋다. 프로그래밍은 중복제거가  가장 중요하다.

Animal
이름, 생년월일

Dog, Cat, Duck은 Animal의 자식클래스이다.

공통필드 : 이름, 생년 월일 

추상화한 필드는 모두 private로 숨긴 다음에(은닉화), getter&setter를 만들어야 한다.
getter & setter는 기본형태만 주면서, 그 안에 이제 개발자의 마음대로 유효성 검사를 넣는다.
setter만 만지면 된다.

Dog를 생성하면, super의 생성자도 호출한다. 

Dog( ) {
     super( );
}

=== super( ); ===

public Animal( ) {
     sysout
}

----------------------------------------------------------------------------------------------------------------
Cat은 기본생성자를 만들진 않았지만, 생략되어져 있다.

생략되어진 Cat의 기본생성자는

public Cat( ) {
     super( ); << 이게 생략되어져 들어가 있다.
}

부모클래스가 없다면

public Cat( ) {

} << 이렇게 되어져 있다.

★ 자식클래스의 기본생성자에서는 부모클래스의 기본생성자가 들어가있는데 생략되어져 있다.
★ 자식클래스의 생성자 안에는 항상 부모클래스의 생성자가 맨 윗줄에 있어야 한다!!
----------------------------------------------------------------------------------------------------------------
강아지 생성자이든, 고양이 생성자이든, 오리 생성자이든 생성자안에서 부모클래스의 기본생성자를 호출하기 때문에 부모클래스의 기본생성자에 스태틱변수인 count++; 를 넣어서 배열 안에 인스턴스가 몇 개 있는지 파악한다.

* 필드는 항상 클래스 맨 위에다 적어야 한다.

필드 ==> 생성자 ==> 메소드 순으로 적는다.

*this는 생략 가능하다.

자식클래스가 부모클래스의 메소드를 끌어다 쓸 때는super.getName(); // this.getName(); // getName(); 중에 아무거나 써도 된다.


부모클래스에 있는 메소드를 자식클래스에서 재정의하면 덮어씌워져서 출력되는데, 만약 재정의를 안했다면 그냥 부모클래스의 메소드대로 출력된다.


@Override		// @XXXX 을 애노테이션(어노테이션)이라고 부른다.
>> Override 애노테이션(어노테이션)은 메소드의 재정의를 할때 쓰이는 것이다.


메소드를 재정의하려고 했으나 ,실수로 메소드의 이름을 잘못적을 수 있으니 메소드 이름 위에 @Overide를 적어서 내가 부모클래스와 똑같이하고 있는지, 틀리게 했는지를 알 수 있다.

@Override (부모클래스와 메소드를 똑같이 만들어서 껍데기만 바꾸고 있는지 확인하는 척도)
public void showInfo( ){ 이렇게 적으면 껍데기가 부모클래스와 똑같이 만들어야 빨간줄이 안 뜬다.
>> 부모클래스의 메소드와 파라미터, 메소드 명이 모두 똑같아야 한다.

또한 부모의 메소드에서 접근제한자를 public이라 썼으면 같든지, 더 커야한다.
public > protected > default > private 순이다.
>> 메소드의 오버라딩시 접근제한자는 부모에서 정의해둔 접근제한자 보다 크든지 또는 같아야 만한다.

★★★★★ 면접에서 주로 메소드의 오버로딩과 메소드의 오버라이딩을 자주 물어본다.
>>메소드의 오버로딩 : 메소드명은 같으나, 파라미터의 갯수나 순서가 다른 것이다. 그래서 이름이 똑같더라도 서로 다른 메소드로 보기때문에 중복됐다고 안 보며, 리턴타입은 관계가 없다.

>>메소드의 오버라이딩 : 부모클래스에서 정의해둔 메소드를 자식클래스에서 재정의 하는 것이다. 단, 부모클래스에서 정의해둔 메소드와 껍데기가 똑같아야 하며, 자식클래스의 접근제한자는 부모클래스와 같던지 더 커야한다.
** 리턴타입도 똑같아야 한다. 부모가 void이면 자식도 void
** source -> Override/implement Methods에서 간편하게 재정의를 할 수 있다.

항상 저장장소와 메소드의 위치가 중요하다 만든것은 dog, cat, duck이지만 저장장소는 Animal의 배열이기 때문에 그 안에는 run, jump, swim의 메소드가 없기 때문에 호출을 할 수 없다.

cry는 부모의 메소드이지만, 자식클래스에서 재정의를 했기 때문에 dog.cry()를 하면 자식클래스에서 재정의된 메소드가 호출된다.
하지만, run과 jump, swim은 재정의 메소드가 아닌 각자의 클래스에서 만들어진 메소드이다.

if(aniArr[i] instanceof 클래스명 )는  'i번째는 어떤 클래스의 인스턴스입니까?' 란 뜻이다.
((Dog)aniArr[i]).run(); // 강제형변환을 시켜준다.

** aniArr[i]는 지금 개인지 고양인지 오리인지 모르기 때문에 조건문으로 instance of로 강아지가 맞다면 강아지로 형변환 시켜서 강아지에 저장된 메소드를 실행시켜준다.

★ 다형성이 없다면, 강아지용 배열, 고양이용 배열, 오리용 배열을 3번이나 만들어야 하지만, Animal 배열을 하나 만듬으로써 여기에 모두 넣을 수 있다. 게다가 for문도 3번이나 써야해서 소스가 난잡해진다.
ex. Animal [] aniArr = new Animal[5]       vs         dog [] dogArr = new Dog[5], Cat [] catArr = new Cat[5], ~~

=======================================

[추상메소드]


메소드이라면 본문({와 } 사이의 내용)이 있어야 한다.

	// abstract class == 추상 클래스 == 미완성 클래스
	// 추상 클래스(미완성 클래스)란? 추상 메소드(미완성 메소드)를 가지고 있는 클래스를 말한다.

부모클래스에서 만든 public abstract void cry();<< 이 바로 추상(미완성)메소드이다.
부모클래스명도 public abstract class Animal처럼 추상(미완성)클래스임을 알려야 한다.
★★★★★ 부모클래스에서 미완성 메소드를 만들었다면 자식클래스에서 재정의를 꼭 해야한다.

[중간정리]
1. 부모클래스에서 미완성메소드를 만듬
2. 자식클래스에서 미완성메소드를 완성시켜줘야 한다.
★ 추상화와 추상메소드는 다른 뜻이다.
** 또한 추상클래스는 패키지익스플로러에서 아이콘 옆에A자가 붙어있다.

>>자식클래스에서 미완성메소드를 완성시켜주지 않으면 오류가 나온다.
*implement : 재정의, 구현



배열의 타입이 추상클래스여도 상관이 없는게, 그냥 그 타입의 정보만 넣겠다는 선언일 뿐이니 상관없다.
// 배열도 객체여서 null이 들어가도 상관없다. String이 null값이 들어갈 수 있듯이
// 객체이긴하나, 저장소이다. 어떠한 데이터타입을 담는 저장소이다.
// 추상클래스든 상관없이, 앞에 써진 인스턴스타입은 그냥 그 타입의 정보를 담는다는 뜻일뿐이다.



내일 : 구직자&구인회사를 다형성으로 바꾸기
