06월 28일 오전수업

랜덤, 배열

★ 옆사람꺼랑 내껄 비교하지말고, 어제의 나와 오늘의 나를 비교해라.
★ 안되면 될 때까지 계속해서 붙어서 코드를 이해하고 풀어보자
★ 처음이라 쉽지 않다. 하다보면 다 올라간다. 최대한 현장강의에 많이 나가서 물어보자


==============================================================
[가위 바위 보 랜덤뽑기]
GawiBawiBoMain4.class

경우의 수 : 3개 

문자열의 값을 비교하는 것은 equals 이다.

do~while의 continue;는 do의 처음부분으로 올라가게 한다.

int rndNum = rnd.nextInt(마지막수 - 처음수 + 1)+처음수;

경우의 수
1. 1234 중에 안 고른 경우
2. 123을 고른 경우
3. 4을 고른 경우
==============================================================
[배열]
ArrayMain1.class

array : 배열

★ 배열 또한 객체임을 기억해야 한다.

배열의 인덱스 또한 0 부터 시작한다.      * 문자열의 인덱스 또한 0 부터 시작한다.
★ 단 뒤에 배울 데이터베이스(오라클)에서는 1부터 시작한다.

배열의 인덱스를 "배열의 방번호"라고 흔히 부른다.

★ 배열로 선언된 변수에는 자동적으로 초기값이 들어간다. (지역변수여도 자동적으로 초기화 된다.)
★ 정수는 0, 실수는 0.0, char는 ' ', String 을 포함한 객체는 null 이 들어간다.  

★ 배열의 크기(길이)는 배열명.length 로 알아온다.

★ 배열의 선언과 메모리 할당, 데이터 값 넣기까지 
★ int[] subjectArr4 = {100, 90, 95, 70, 98, 100, 90}; 다음과 같이 주로 많이 쓴다.

==============================================================
[배열로 회원가입 만들기]
MemberMain3.class

while(!(    ))

(조건)이 참이라면, 빠져 나온다.

System.out.println("\n=========  >> 메 뉴 <<  =========");
	        System.out.println("1.회원가입 2.모든회원조회 3.프로그램종료");
	        System.out.print("▷ 선택하세요 => ");
	        
try {
menuNo =  Integer.parseInt(sc.nextLine());
} catch (NumberFormatException e) {
System.out.println(">> 정수만 입력하세요!! <<");
}

잘못 쳤으면 빠져나가서 처음의 do부터 다시 시작해야 하니깐 try에 메뉴선택은 빼놓고 써야한다.


* MyUtil 에 비밀번호 체크용 스태틱메소드 만들기

1. 널값 분류
2. 글자수 분류
3. 대문자, 소문자, 숫자, 특수문자 유무 확인
4. 정책에 맞게 했는지, 틀리게 했는지 분류


mbr 필드들에 각 회원마다의 정보들을 넣어주고 
(이순신(mbr)님의 id, passwd, name 들을 만들어서 넣고, 강감찬님의 ~, 엄정화님의~ )

mbr 필드들이 채워졌으면 mbrArr에 각각 넣어서 정리해준다.
(mbrArr[0] - 이순신님의 id, passwd, name 정보들이 들어가진다.
 mbrArr[1] - 강감찬님의 ~
 mbrArr[2] - 엄정화님의 ~ )

==============================================================
06월 28일 오전수업

[스태틱변수로 배열에 빈자리 있나 확인하기]
if로 mbrArr이 다 비어있다면 nullPoint 오류가 안 뜨게 처리한 것을 static 필드를 이용해서 처리하는 방법을 할 것입니다.

멤버변수 = 인스턴스변수 + 스태틱변수
>> 자동 초기화

스태틱변수와 기본생성자를 이용한 멤버수 세기
★ 스태틱 변수는 같이 공유한다.
★ 스태틱 변수는 인스턴스 객체 갯수를 파악하는데 좋다.

System.out.println(">> 확인용 count : " + Member2.count");
요렇게 적어두면 회원의 정보를 넣을 때마다 횟수가 1씩 늘어나서 몇 명이 채워졌는지 알 수 있다.

==============================================================

[4.특정아이디로 회원조회]

7. 특정 아이디로 회원정보 조회하기
   7-1. 먼저 배열의 길이를 확인한다. 0이라면 모두 null이니 가입된 회원이 없음을 알린다.
   7-2. 조회하고자 하는 아이디를 스캐너로 입력받는다.
   7-3.mbrArr[i].id.equals(searchID)를 조건으로 한 if절로 같은 아이디가 있는지 찾은 다음에 있다면 정보를 보여주고 break를 통해 for문을 빠져나간다.

==============================================================

[공백제거하기]
SpaceDeleteMain4.class
String str = "  korea   seou l  ";

char[ ] chArr = str.toCharArray( );

-----------------------------------------------
|' '|' '|'k'|'o'|'r'|'e'|'a'|' '|' '|' '|'s'|'e'|'o'|'u'|' '|'l'|' '|
-----------------------------------------------

for(int i = 0; i<chArr.length; i++) {
if(chArr[i] != ' ') {
   len++;
   }
}

len = 공백이 아닌 글자 개수


for(int i=0, j=0; i<chArr.length; i++, j++) {
//   resultchArr[j] = chArr[i];
// 그냥 이렇게 쓰면 chArr[0]과 [1]은 공백이라서 resultchArr에 공백도 들어간다.
// 또한 공백까지 포함해서 넣어버리면 크기를 오버해서 ArrayIndexOutOfBoundsException이 뜬다.

if(chArr[i] != ' ')
     resultchArr[j] = chArr[i]; // 공백이 아닌 것들만 모은다.

else
     j--; // 공백일땐 증감된 j값을 내려줘야 공백이 아닌 글자 개수(len)에 맞출 수 있다.
// resultchArr[0] = chArr[2]; 
// chArr은 2가되서야 공백이 아닌 글자가 나옴.


char인 배열의 값을 문자열로 만들기

for(char ch : resultchArr){
     result += ch;
} // 얘는 하나하나 누적해서 문자열로 만들기

String.valueOf(resultchArr) 얘는 배열의 값들을 한 번에 문자열로 만든다.





==============================================================[로또]
LottoMain5.class

★★★ int idx의 난수값들 => tempArr의 데이터값으로 들어감 => 후에 ballArr의 방 번호가 됨 => 그 방 번호의 데이터값(로또번호)를 뽑아옴

1. int [] ballArr = new int[45]; 로 총 45개의 배열의 방번호를 개설

2. 배열 안에 값들은
for(int i=0; i<ballArr.length; i++){

          ballArr[i] = i+1;
// 0호실에는 1, 1호실에는 2, ...... , 44호실에는 45
// 데이터 값은 1 ~ 45

}

====================중간 정리 ========================
배열의 길이는 : 45
배열 안에 들어간 데이터값은 1 ~ 45

3. 로또 6개를 추첨해야한다. 0~44번 방번호를 뽑아야하기에 0~44까지의 난수를 6번 뽑는다.

4. int idx = 난수;  for문을 통해서 6번 반복한다.

5. tempArr을 이용해 검수를 한다. tempArr[i] = idx;로 난수 값을 tempArr의 데이터값으로 넣는다.

6. 그 후에는 if(idx == tempArr[j])를 통해서 첫번째 이후 숫자를 뽑았는데 똑같은 값이 나온다면 기회를 새로 주기위해서 i--;로 차감시키고 continue를 통해 난수뽑기 for문을 다시 보낸다.

* tempArr을 5개만 준 이유는?

>> 1, 2, 3, 4, 5번째 값들은 차곡차곡 넣어서 전 번째 값들이 들어올 때마다 서로 대조해서 비교해야하지만 마지막 6번째 값들은 for문을 이용해서 idx와 5번째 값들까지 저장된 tempArr[j]를 비교했을 때도 문제가 없다면 굳이 tempArr에 넣지않고 바로 ballArr[idx]에 넣어서 마지막 값을 뽑으면 된다.

* tempArr에 데이터값을 모두 -1로 준 이유는?
>> idx 난수로 값을 뽑아왔는데 0이 나올 가능성도 있다. (0~44의 난수값, 이는 후에 ballArr의 방번호가 되어서 그 방번호의 로또번호를 호출함)
>> 만약 그렇게 된다면 배열로 선언된 int 변수에는 알아서 초기화로 0이 들어가는데 -1로 바꿔놓지 않는다면, 나는 첫번째로 0을 뽑은 것인데 알아서 초기화된 0이 들어가있어서 중복을 뽑은 것으로 로직이 인식할 수 있다.

★★★ int idx의 난수값들 => tempArr의 데이터값으로 들어감 => 후에 ballArr의 방 번호가 됨 => 그 방 번호의 데이터값(로또번호)를 뽑아옴

====================총 정리 ========================
ballArr의 길이는 45
배열 안에 들어간 데이터값들은 1부터 45 (로또번호들)

1. int idx = Random클래스를 이용한 난수뽑기; 를 통하여 임의의 방번호 6개를 뽑는다.
2. idx 값들을 tempArr에 넣는다.
  2-1. 미리 들어가 있는 tempArr[j] 값들을 for문을 통하여 idx와 하나하나 비교해서 중복이 아니라면 tempArr[i]에 넣는다.
3. tempArr을 통하여 중복이 아님이 검증된 idx값들을 ballArr[idx]로 넣어서 ballArr[idx]의 로또번호 값들을 뽑아내서 출력한다.


