07월 08일 오전수업

[컬렉션 - List]

배열은 한 가지의 데이터 타입만 들어갈 수 있지만, 
컬렉션은 여러가지 객체타입이 들어갈 수 있다.

** List 계열은 저장소에 추가할 때, 리스트명.add(객체)를 쓴다.
==> 원래는 객체에 넣을 때, boxing으로 써서 넣어야 한다.
==> 허나, 자바에서는 원시형 자료들도 알아서 auto boxing을 해서 넣어준다.

** 저장소에서 자료를 꺼내올 땐 리스트명.get(i);이다.
꺼내어 올 때도 얘가 무슨 타입인지 모르니깐 일단 Object 타입으로 받아오는 것이다.

** 저장소의 길이는 리스트명.size( );이다.

허나, 뒤죽박죽 섞여있어서 찾아오는데 시간이 걸리는데,
제네릭을 이용하면 이 문제를 해결할 수 있다.

Object가 최상위 부모클래스이지만, 거기에 minfo( )나 pinfo( )가 없기 때문에 메소드 호출창에 안나온다.
==> 그래서 형변환을 해줘야 한다.
==> 무슨 타입이 나올지 모르니깐 Object로 받고, 그 받은 것들 중에서 Product나 Member타입이 나오면 그때 if절의 명령실행문을 실행한다.

----------------------------------------------------------------------

[제네릭]

맨처음에 자바에서 의도한 바는 컬렉션이 배열의 단점을 보완하려했던 것이다.
==> 개수 무제한, 객체이면 모두 다 받을 수 있다.

근데 막상 써보니깐, 자료를 꺼내올 땐 너무나 불편했다. 만약 길이가 10000이라면, 그 자료타입에 맞는 것을 찾으려고 for문을 1만번이나 돌려야 했기 때문이다.

그래서 '제네릭'이 나왔다.

Class ArrayList<E>

==> <E> 가 바로 제네릭이다.
==> 이 때, E는 Element 구성요소이다. 즉, 객체이다.

<E>는 마치, 배열처럼 어떤 ArrayList는 특별한 객체만 받는 것이다.

(ex1)
ArrayList<Member> arrList = new ArrayList<Member>();
==> ArrayList이긴 하지만, 멤버타입의 객체만 받아주는 저장소
==> List<Member> mbrList = new ArrayList<Member>(); 이렇게도 쓴다.

JDK 1.7부터 ArrayList<Member> mbrList = new ArrayList<>();
뒤쪽 제네릭은 생략 가능하다.
★ 허나, 앞쪽 제네릭은 생략 불가능이다.


배열에서 확장for문은 처음에 선언한 길이만큼 작동해서 빈 방도 가져와 null값이 나올 수 있었지만, List에서는 값을 넣은 만큼만 방의 길이가 늘어나기 때문에 확장for문을 사용하기에 좋다.

==> 제네릭을 사용시, 저장갯수는 무제한이지만 특정객체타입만 받아서 꺼내올 때 편하다!

----------------------------------------------------------------------

[ArrayList]

[1. 출력시 저장된 순서대로 나온다.]

★ ArrayList 는 데이터값이 동일한 객체를 저장할 수 있다. 
==> 데이터값은 같지만, 새로운 객체이다.
----------------------------------------------------------------------

[2. 중복된 데이터를 저장할 수 있다.]

퀴즈 2번은 "문자열".startswith("찾고자하는문자열")를 이용하면 좋다.
=> 찾고자하는문자열과 문자열이 동일하면 true, 아니면 false
=> if(name != null && name.startsWith("이"))
** substring보다 편함

★ 항상 NullPointerException을 생각해야한다. 배열 혹은 리스트들 중에 null값이 있을 수 있다는 염두를 하면서, 맨 처음에 null값이 들어올 수 있는 경우를 쳐내야한다.


----------------------------------------------------------------------

[3. mbrList의 특정한 위치에 추가하기]

>> 객체를만들면서 인덱스번호를 안 쓰고, add를 하면 맨 뒤에 넣어진다.

mbrList.add(3, new Member("chaew","qwer1234$","차은후"));
이렇게 쓰면 3번째 index에 이 값을 넣고, 원래 3번째에 있던 값을 한 자리 뒤로 밀어버린다. (새치기한다)

----------------------------------------------------------------------

[4. mbrList에 저장되어진 객체 삭제하기]

mbrList.remove(int index);
>> i번째에 저장된 객체를 없앤다.
>> 그 뒤에 있는 i+1번 값들이 앞으로 땡겨진다.


** add 하면 밀려버리고,
** remove 하면 땡겨진다.


[이순신은 삭제됐는데, 이민호가 삭제되지 않은 이유는??]
remove는 해당 인덱스번호 값을 삭제하고, 그 삭제된 인덱스번호에 뒤에있는 값들을 넣는다.
★ 앞에서 이씨를 하나 삭제해버리면 인덱스값들이 땡겨지는 것이니 주의해야 한다.

// 0(유재석) 1(엄정화) 2(강호동) 3(이순신) 4(김태희) 5(강감찬) 6(null) 7(이순신) 8(이민호) 9(설현)
// 3(이순신) 을 삭제함. i=>3 일때 삭제, i=>4 시작

// 0(유재석) 1(엄정화) 2(강호동) 3(김태희) 4(강감찬) 5(null) 6(이순신) 7(이민호) 8(설현)
// 6(이순신) 을 삭제함. i=>6 일때 삭제, i=>7 시작

// 0(유재석) 1(엄정화) 2(강호동) 3(김태희) 4(강감찬) 5(null) 6(이민호) 7(설현)
// 이민호는 땡겨져서 6번이기 때문에, 7번부터 시작하면 설현이 잡힘

★ 증감식이 아니라, 가감식으로 뒤에서부터 찾아서 삭제하면, 숫자가 땡겨져서 값이 바뀌는 것을 해결할 수 있다.

이씨가 연속이 아니라, 불연속이라면 증감식도 괜찮지만, 연속적이라면 숫자가 땡겨지느라 제대로 검사해서 삭제를 못한다.

★★★ 삭제할땐(remove), 가감식으로 List 끝 방에서부터 찾도록 한다.


----------------------------------------------------------------------

[5. mbrList에 저장되어진 모든 객체 삭제하기]
mbrList.clear();

----------------------------------------------------------------------

[특징 정리]
1. ArrayList는 출력시 저장된 순서대로 나온다. (add)
2. ArrayList는 중복된 데이터를 넣을 수 있다. (** 객체는 다르지만, 데이터값이 같다!)
3. ArrayList는 LinkedList 보다 상대적으로 데이터를 읽어오는 속도가 빠르다.
4. 순차적으로 데이터 추가/ 삭제는 ArrayList가 빠르다
5. 중간중간 데이터 추가/삭제는 LinkedList가 빠르다.
6. LikedList나 ArrayList든 결과값은 똑같다.
7. LikedList 보다 ArrayList를 사용하도록 하자


>> 받을 때 List mbrList = new ArrayList(); 로 받아서, 다형성으로 ArrayList, LinkedList 모두 다 받을 수 있다.
>> new만 ArrayList, LinkedList 차이일 뿐이다.
>> add, remove, clear 다 똑같다. 

List 인터페이스에는 추상메소드들이 다 있어서, ArrayList든지 LinkedList든지 뭐가 오든 똑같다.(★다형성으로 둘 다 받아줌, 둘 다 List 인터페이스를 구현한 것들이여서)

===========================================

07월 08일 오후수업


[LinkedList]

==> 중간중간 데이터 추가/삭제는 LinkedList가 빠르다.

add를 할 때마다 들어가서 앞서 있던 객체의 메모리주소와 연결되서 저장되어진다.

ex.  1번(자신의 메모리주소 1372)----(앞서존재하던객체의 메모리주소 1372)2번(자신의 메모리주소 3236)----(앞서존재하던객체의 메모리주소 3236)3번(자신의 메모리주소 1034)

** ArrayList에서는 삭제하면, 모든 인덱스번호가 한 칸씩 땡겨진다.
** LinkedList에서는 앞의 객체에 메모리주소만 바껴진다.
>> 그래서 중간에 있던 것이 삭제가 빠르다.
>> (앞의 객체 메모리주소)2번째 객체 
>> Array는 모든 인덱스번호를 -1해야해서 느리고, Linked는 앞의 객체 메모리주소 1번만 바꾸면되서 중간에 추가/삭제가 더 빠른것이다.


>> 추가 또한 마찬가지로 인덱스번호를 +1 해야하는데, Linked는 그냥 사이에 넣은 다음에 끼어들어간 객체에 앞의 객체 메모리주소만 바꿔주면 끝이여서


신규회원가입은 그냥 뒤에 차곡차곡 쌓아주면 된다.
==> 중간에 끼어들 일이 없다.
==> 그래서 ArrayList가 훨씬 빠르다.
==> LinkedList는 주소를 보면서 꼬리를 물며 메모리주소가 연결되지 않은 자리를 찾아가야해서

전체를 다 읽어볼때는 ArrayList가 그냥 인덱스번호만 짚으면서 가기에 빠르다.

===========================================

[Map]

Map 계열에서는 HashMap을 많이 쓴다.

Map<K,  V>
K : key , 대부분 String 타입이다.
V : value , 일반적으로 Object, 객체이다.
★ 키값은 반드시 고유한 값을 가져와야 하고, 벨류값은 중복가능

==> Map<String,Member> mbrMap = new HashMap<>();
==> 키값은 String타입으로, 객체는 Member 타입만 넣는다.

** HashMap : 웹용, 가볍다, 멀티쓰레드 미지원
** HashTable : 게임용, 무겁다, 멀티쓰레드 지원

값을 넣을 땐, put // 값을 꺼내올 땐, get
>> List는 add, get

★ 마찬가지로 앞쪽 제네릭은 생략 불가능, 뒤쪽 제네릭은 생략가능
==> Map<String,Member> mbrMap = new HashMap<>();

키값만 알면 그 키값에 value를 가져온다. (키 값은 id호출자와 같은 개념이다.)

★
리스트는 넣을 땐 add(Object), 꺼내올땐 get(인덱스번호)
맵은 넣을 땐 put(키값, Object), 꺼내올땐 get(키값)


★ 특정한 한 개체를 딱 뽑아올 땐, 맵이 리스트보다 빠르다.
(== 특정한 회원을 찾아올 때는 리스트보단 맵이 빠르다.)

ex. List와 Map이 10만개의 값들을 각각 가지고 있다고하면, List는 인덱스번호로 부여해서 for문으로 10만개를 쫙 다 돌려서 내가 찾고자하는 객체를 찾아야한다.
하지만, 맵은 내가 키값만 안다면 다 돌릴 필요도 없이, 키값만 딱 주면 바로 그 객체를 뽑아와준다.


없는 키값으로 검색을 하면 null이 뜬다.
★ null.메소드( ) ==> NullPointerException
>> null이 있는지 없는지를 구분해야 한다.
>> 무조건 찾는 값이 맵 안에 있는 것이 아니다. 없을 수도 있다.


★키값이 고유한 것으로 나오지 않으면, 이전에 있던 것을  새로운 것으로 덮어 씌워버린다.
  mbrMap.put("leess", new Member("leess","qwer1234$","이순신"));
 mbrMap.put("leess", new Member("leess","qwer1234$","이삼신"));
==> 이삼신을 출력한다. 전에 있던 벨류값이 덮어씌워버려진다.
==> 데이터가 똑같아도, 키값만 다르면 된다.

----------------------------------------------------------------------
[Map의 모든 정보 출력하기]
모든 키값을 알아야만, 모든 정보를 출력 해올 수 있을 것이다.

== mbrMap 에 저장되어진 모든 key 들을 읽어오는 첫번째 방법 ==

==> 맵 이름.keySet();

Set<String> keySets = mbrMap.keySet();

for(String key :keySets) {
     System.out.println(key);
}// end of for----------------------------

** key는 항상 거의 String이다.
** 문자는 암기가 쉬운데, int로하면 암기하기 힘드니깐~
** Map 계열에 저장된 key값들은 순서와는 상관없이 저장된다.

==> get에 키값만 넣어주면 벨류값이 툭 튀어나온다.
==> 그리고 그 벨류타입의 객체로 받아줘서 sysout으로 출력
----------------------------------------------------------------------

== mbrMap 에 저장되어진 모든 key 들을 읽어오는 두번째 방법 ==

[Iterator]
Set<String> keySets2 = mbrMap.keySet(); 은 저장소이다.
Iterator<String> it =  keySets2.iterator(); 은 저장되어진 요소를 읽어오는 용도이다.

>>it에 keySet2에 저장된 값들을 모두 넣어준다(저장하는게 아님)


Set<String> keySets3 = mbrMap.keySet(); // 이 Map의 모든 키값을 keySets3에 저장한다.
Iterator<String> it = keySets3.iterator();

while(it.hasNext()) {
     String key = it.next();
     System.out.println(mbrMap.get(key).minfo());
}
===========================================

[Map에서 특정데이터 삭제하기]
mbrMap.remove("키값"); << 이 키값의 객체를 없앤다.

[Map에서 모든 데이터 삭제하기]
mbrMap.clear( );

===========================================

**ArrayList와 HashMap만 알면 다 짤 수 있다.

[Set]

HashSet와 LinkedHashSet의 차이점
출력시 저장된 순서가 유지되느냐, 안되느냐이다.
==> HashSet는 순서유지X , (메모리주소)중복X
==> LinkedHashSet는 순서유지, (메모리주소)중복X


*ArrayList는 중복된 데이터를 넣을 수 있다.

Set 계열은 Iterator 통해서만 저장된 데이터 요소를 접근해서 읽어올 수 있다.

HashSet 은 제거를 이터레이터를 사용해서 삭제해야 한다.
it.remove( );

===========================================

[Properties]
Properties 는 (String 키, String 밸류값)의 형태
키는 고유해야한다. 중복허용X // 중복된 값을 넣으면 마지막에 넣은값으로 덮어씌운다. 

HashMap과 거의 비슷하나, 벨류값은 String만 들어올 수 있다.

* 스트링타입으로 되어있는 긴 URL을 키값으로 짧게 만들어서 호출한다. 웹에서 주로 쓴다.

<?> : 아무거나를 뜻하는 것이므로, Object와 같다.



===========================================
[정리]

ArrayList (필수)
HashMap (필수)
Properties  (조금조금 쓴다.)

Set은 순서를 유지하지 않는 데이터 집합이다. 데이터의 중복을 허용하지 않고, HashSet, TreeSet 등이등이 있다.
(Wrapper 클래스의 데이터값의 중복을 허용하지 않으며, 우리가 만든 객체들의 대한 값은 중복을 허용한다. ==> equals와 hashcode를 재정의해서 바꿀 수 있다.)
 
List는 순서를 유지하는 데이터의 집합이다. 데이터의 중복이 허용되고, LinkedList, ArrayList 등이등이 있다.
(Wrapper 클래스의 데이터값의 중복을 허용한다.)
 
Map은 키(Key)와 값(Value)으로 이루어진 데이터의 집합이다. 순서는 유지되지 않으며, 키는 중복을 허락하지 않는다. Map의 클래스로는 TreeMap, HashTable, HashMap등이 있다.