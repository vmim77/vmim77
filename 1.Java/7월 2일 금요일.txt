07월 02일 오전수업

[접근제한자]
필드는 거의 다 private로 감싸버려서 외부에서 직접적으로 데이터 변경을 못하도록 막는다.
private는 자기자신클래스내부에서만 사용할 수 있기 때문에, 메소드를 이용하여 값 변경등을 해결한다.
메소드 : getter(값을 읽어온다.), setter(값을 넣어준다.) << 대신에 개발자가 정한 조건에 해당됐을때만 넣어준다.

아무것도 안 적은것이 default이다.
==========================================================================
[캡슐화 EnCapsulation]
= 은닉화

1. 필드를 모두 private로 만들고 getter, setter를 만든다.
2. 정규표현식을 이용한 아이디 setter 만들기
3. MyUtil.isCheckPasswd를 이용한 비밀번호 setter 만들기
4. 정규표현식을 이용한 성명 setter 만들기
5. isCheckJubun을 private 메소드로 만든 후에, 주민번호 setter 만들기

6. 잘못된 값이 들어가면 유효성 검사에 걸리면 초기화가 null로 되어서 NullPointerException이 뜨는데 방지하기 (+ 또한 잘못된 값이 들어와도 바로 배열에 넣는 것 막기)

>> 배열에 넣기전에 값들이 다 올바른지 확인하고, 맞으면 넣게한다.
>> gu1도 써야하고, gu2도 써야하고, gu3도 써야하니 메소드로 만들어서 필드값에 null값이 있나 없나를 확인하고, null값이 없으면 배열에 값을 넣어준다.
>> GujikjaCtrl에 public boolean checkGujikja(Gujikja gu)를 만든다.

(method의 오버로딩)
- 리턴타입이 달라도 파라미터가 똑같으면 같은 메소드로 본다.
- 파라미터가 뭐냐에 따라 이름이 같아도 다른 메소드가 된다. (파라미터의 타입, 순서, 개수에 따라서)

7. register 메소드 수정하기 
     7-1. setter에 유효성검사를 다 넣어서 만들었기 때문에, 굳이 if 구절로 공백이 있나 없나, null값이 있나 없나를 확인할 필요가 없다.
     >>올바르게 넣을 때까지 (field값이 null이 아닐 때까지) do~while을 돌리면 된다.
     >>모든 필드들이 null이 아닐때까지 계속해서 돌아가는 do~while이 적혀져 있다.'
     >> 마지막에 checkGujikja로 한 번 더 필드마다 null이 있는지 확인한다. (** 안해도 괜찮지만 재확인용이다.)
.
★ 항상 set으로 값을 일단 넣어보고 get으로 불러와서 null인지 아닌지 확인한다.
★ 웹을 넘어가면 필드는 무조건 private로 줘야하고, setter&getter는 필수이다. 안그러면 JSP나 웹에서 오류가 뜬다.

==========================================================================
[상속성 Inheritance]

구직자만 있으니, 이제는 구인회사도 추가해야 한다.
-구인회사 회원가입, 구직자 로그인, 구인회사 로그인, 모든 구인회사 보기, 로그아웃, 내정보 변경하기 추가


[1. 구인회사 클래스 만들기, 구인회사용 저장장소(배열) 만들기]

구인회사 클래스 = Company.class

1-1. 필드생성
구직자의 아이디, 암호, 성명, 연락처와 컴퍼니의 아이디, 암호, 회사명, 담당자연락처는 용도가 똑같다.
똑같은 것은 매번 하지 않는 것이 코딩에서 가장 좋은 것이다.(메소드처럼 매번 똑같은 기능을 직접 치는것을 방지하려고)

구직자 클래스와 구직회사 클래스는 Member에 있는 서로 공통된 필드를 쓰겠다고 선언한다.
★ 중복을 피하기 위해서이다.

public class Gujikja extends Member << 이 말은 Gujikja 클래스는 Member 클래스에 선언되어진 필드와 메소드를 상속받아서 쓰겠다는 말이다.

public class(자식클래스명) extends Member(부모클래스명)
이미 Gujikja에 만들어진 userid, passwd, name, mobile은 지워야 한다. 
지우면 눈에 안보이지만 extends Member 때문에 Member에 있는 필드가 이미 다 들어가져 있는 것이다.

주민번호와 희망연봉은 Gujikja만 써야하고, 회사직종과 자본금은 Company만 써야한다. 그래서 각 클래스에 각각 만들어 놓고 있는 것이다.


★ 이렇게 공통된 필드와 메소드를 부모클래스에 만들고 자식클래스가 끌어다 쓰는 것을 상속이라고 한다.

부모클래스인 멤버도 default이기에 개발자가 원하는 대로 데이터가 안 들어올 수 있기 때문에, 부모클래스도 접근제한자로 다 막아줘야 한다.

Gujikja에서 공통필드 getter & setter 옮기기

★ 자기, 나 자신의 대명사는 'this', 부모의 대명사는 'super'이다.

== 구직자 정보보기 메소드 변경하기 ==
userid, passwd, name을 모두 super.id, super.passwd, super.name으로 바꿔준다. (부모의 아이디와 비밀번호, 이름을 가져오겠단 뜻이다.)

==========================================================================
07월 02일 오후수업

[1. 구인회사 클래스 만들기, 구인회사용 저장장소(배열) 만들기]
자식클래스는 부모클래스의 필드와 메소드를 끌어올 수 있지만, 접근제한자가 private면 부모클래스여도 못 끌어다 쓴다.
==> 그래서 필드를 못 끌어다 쓰니, getter&setter는 public으로 해놓고 끌어다 쓰게 한다.

부모클래스여도 필드는 private로 해서 무분별한 값 변경을 막아야 한다.

1. 직종타입은 여러가지 많으니 setter에 딱히 제한을 안 준다.
2. 자본금, 회사직종타입 setter에 유효성검사 넣기
 >> if(jobType != null || !(jobType.trim().isEmpty())) 로 하면 null은 아닌데, 공백이 있어도 true를 반환해서 &&로 해야한다. 

3. 구인회사 회원가입 만들기
구직자 회원가입과 메소드명이 똑같지만, 파라미터가 달라서 다른걸로 본다.(★메소드의 오버로딩)
=> 리턴타입이 다르다고 다른건 아님, 파라미터가 달라야 한다.

4. compArr = {"LG", "samsung"}

아이디 스캐너에 LG입력, setter에는 중복검사가 없기 때문에 this.id = "LG";를 다시 넣는다.
이후 register 메소드에 다시 돌아와서 중복검사에서 걸리기 때문에 중복이란 메세지를 출력한다.

그래서 break를 못 만나서 다시 "아이디 : "가 출력된다. 여기서 그냥엔터를 하면, setter에 정규표현식에 걸려서 메세지를 출력한다. (현재 getId( )는 "LG", 스캐너의 지역변수는 그냥엔터)

그래서 null값 검사에서는 "LG"가 들어가서 걸리지 않고, 중복검사에서는 "LG", "samsung", "LG"와 지역변수 id인 그냥엔터가 검사되니 또 걸리지 않는다. 이후 중복이 없는 아이디로 넘어가서 그냥엔터를 setId를 하려니 메세지를 또 출력하고, break를 만나서 다음에 "2. 암호 : "가 또 나온다.



★ 이를 해결하기 위해서, setter들의 else 절에 잘못됐다는 메세지를 출력하고 인스턴스 필드들의 값을 다시 초기화시켜줘야 한다.(null이나 0으로)

그래서 setter에 잘못되서 메세지를 출력하고 null로 다시 초기화를 시켜줘야 한다.

==========================================================================
[구직자&구인회사 로그인 만들기]

아이디와 비밀번호를 입력받아야 하니 파라미터로 스캐너를 넘겨준다.
입력한 아이디와 비밀번호가 저장소에 있는지 확인해야하니 파라미터로 guArr을 넘겨준다.

리턴타입은 boolean이 좋아보이나, 허나 로그인한 구직자(구직회사)를 넘겨줘야 하기 때문에 Gujikja(Company)타입으로 만든다.
GujikjaCompanyCtrl.class

public Gujikja login(Scanner sc, Gujikja[ ] guArr) {

   Gujikja loginGu = null;

   System.out.print("▷구직자 ID : ");
   String input_id = sc.nextLine( );

   System.out.print("▷비밀번호 : ");
   String input_passwd = sc.nextLine(  );

   for(int i=0; i<Gujikja.count; i++){
     String id = guArr[i].getId;
     String passwd = guArr[i].getPasswd;

    if(id.equals(input_id) && passwd.equals(input_passwd)) {
          loginGu = guArr[i]
          break;
     }
   }
   
   return loginGu;
}



GujikjaCompanyMain.class

   case "3" : // 구직자 로그인

     loginGu = ctrl.login(sc, guArr); // 로그인에 성공했다면 loginGu = guArr[i]


★ 추상화 : 필요한 것만 뽑는다.
★ 캡슐화 : 필드를 private로 숨긴다.
★ 상속 : 부모클래스로 자식클래스들의 중복을 줄인다. 


다음주 : 모든 구인회사 보기, 내정보 변경하기 구현하기 //  다형성

다형성이 끝나면 추상클래스, 인터페이스로 넘어간다. 

