10월 19일 화요일 수업

[ 주문 트랜잭션 처리 ]


1. 주문 테이블에 입력되어야할 주문전표를 채번(select)하기 
2. 주문 테이블에 채번해온 주문전표, 로그인한 사용자, 현재시각을 insert 하기(수동커밋처리)
3. 주문상세 테이블에 채번해온 주문전표, 제품번호, 주문량, 주문금액을 insert 하기(수동커밋처리)
4. 제품 테이블에서 제품번호에 해당하는 잔고량을 주문량 만큼 감하기(수동커밋처리) 
	    	    
5. 장바구니 테이블에서 cartnojoin 값에 해당하는 행들을 삭제(delete OR update)하기(수동커밋처리)
>> 장바구니에서 주문을 한 것이 아니라 특정제품을 바로주문하기를 한 경우에는 장바구니 테이블에서 행들을 삭제할 작업은 없다. << 
	    
6. 회원 테이블에서 로그인한 사용자의 coin 액을 sumtotalPrice 만큼 감하고, point 를 sumtotalPoint 만큼 더하기(update)(수동커밋처리) 
7. **** 모든처리가 성공되었을시 commit 하기(commit) **** 
8. **** SQL 장애 발생시 rollback 하기(rollback) **** 

▶ 여러개 제품을 장바구니에서 구매하는 경우
▶ 장바구니에서 제품 1개만 구매하는 경우
▶ 특정제품을 바로주문하기를 한 경우


▶ insert를 위해 맵에 파라미터들을 담아서 넘겨준다.
==> 주문 테이블에는 1개만 들어가고, 주문상세 테이블에는 여러개가 들어갈 것이다.
==> 주문 테이블과 주문상세 테이블은 일대다 관계이다.

▶ public int orderAdd(HashMap<String, Object> paraMap)
- 수동 커밋을 위해 오토커밋을 false를 준다.
- 처음에는 주문 테이블에 insert
- 성공했다면 주문상세 테이블에 insert

※ 주문상세 테이블에 odrprice 컬럼이 필요한 이유
 
판매가는 영구적이지 않다. 장바구니에 담아뒀어도 구매하지 않았기 때문에 그 사이에 판매가가 변한다면 반영을 해줘야한다.

장바구니 테이블에는 제품에 대한 판매가가 없다. 판매가는 fk_pnum을 통하여 참조만 하고있다. (JOIN을 통해서 읽어온다.)

허나 주문상세 테이블도 fk_pnum이 있으니 제품판매가 컬럼이 필요없다고 지우면 안된다. 왜냐하면 판매가는 매번 바뀌는데 이 컬럼을 빼면 다음과 같은 상황이 일어난다.

(예시)
어제 새우깡 판매가 1,000원(제품 테이블)

어제 판매한 것은 새우깡을 5개 판매함. 총판매가 5*1,000원 = 5,000원 (주문상세 테이블) 
===========================================================

오늘 새우깡 판매가 2,000원(제품 테이블) update

어제 판매한 것은 새우깡을 5개 판매함. 총판매가 5*1,000원 = 5,000원 (주문상세 테이블)
오늘 판매한 것은 새우깡을 5개 판매함. 총판매가 5*2,000원 = 10,000원 (주문상세 테이블)
===========================================================
==> 이미 돈을 받은 것은 어제 판매가로 출력을 해줘야하는데 판매가컬럼이 없다면 JOIN을 해서 가져오기 때문에 판매해버린 상품에 대한 가격도 바뀐다.
==> 그래서 주문상세 테이블에는 제품판매가를 직접 넣어줘야한다. (역정규화)
==> 매번 현재 판매가를 JOIN해서 가져오기 때문에 말이 맞질 않는다.
==> 그래서 주문상세 테이블에는 구매했을 그 당시에 판매가를 넣어줘야한다.

※ 장바구니는 넣었을 뿐이지 구매한 것은 아니니깐 odrprice 컬럼이 있으면 안 된다. (매번 현재가격으로 찍어줘야한다.)

- 제품 테이블에서 제품번호에 해당하는 잔고량을 주문량 만큼 감하기
update tbl_product set pqty = pqty - ?
where pnum = ?

- 장바구니에서 구매한 목록을 삭제하거나 수정을 한다.
==> 바로주문하기를 한 경우에는 행들을 삭제할 필요가 없다.
==> cartnojoin은 콤마(,)를 기준으로 연결되어 있으니 where cartno in(?) 을 쓰면 한 번에 다 지울 수 있다.

★★ 허나, in 절에도 위치홀더를 사용하면 안 된다. (마찬가지로 테이블명도 변수로 써야한다.)

in 절에 사용되는 것들은 컬럼의 타입을 웬만하면 number 로 사용하는 것이 좋다.
왜냐하면 varchar2 타입으로 되어지면 데이터 값에 앞뒤로 홑따옴표 ' 를 붙여주어야 하는데 이것을 만들수는 있지만 귀찮기 때문이다.

★★ 데이터만 위치홀더를 줘야하지, 컬럼명과 테이블명에는 위치홀더 주면 안된다.



        	for(int i=0; i<pnumArr.length; i++) {
        		sb.append("\'"+pnumArr[i]+"\',");
        	}// end of for----------------------
        	/*
	            tbl_product 테이블에서 select 시
	            where 절에 in() 속에 제품번호가 들어간다.
	           	만약에 제품번호가 문자열로 되어있어서 반드시 홑따옴표(')가 필요한 경우에는 위와같이 해주면 된다.
            */

====================================================================================

[ 좋아요, 싫어요 (투표)  ]

constraint  PK_tbl_product_like primary key(fk_userid,fk_pnum) 
==> 두 개를 복합 기본키로 만들어서 한 제품에 한 번만 가능하게 한다.

좋아요, 싫어요는 해당 제품을 구매해야 사용할 수 있게 만들어야 한다.

isOrderOK라는 전역변수가 prodView.jsp에 생성되어져있다.

▶ 문서가 로딩되어지면 ajax를 통해서 제품번호와 로그인된 유저아이디를 가지고 가서 조회를 한다.
==> 주문 테이블과 주문상세 테이블을 JOIN 시켜서 비교한다.

▶ 비동기가 아닌 동기처리를 한 이유는 사이트가 실행되자마자(==문서가 로딩되자마자) ajax가 반드시 작동되게해서 isOrderOK를 갱신시키기 위해서이다.
==> 비동기이면 필요할 때만 작동을 하고, 나머지 작업들이 먼저 작업하게 만들기 때문이다.
==> 동기이면 얘가 먼저 작동하고 나머지 작업들은 Stanby 함
==> Ajax 를 이용한 제품후기를 작성하기전 해당 제품을 사용자가 실제 구매했는지 여부를 알아오는 것임.