10월 20일 수업

[ 좋아요, 싫어요(투표) ]

▶ 좋아요(싫어요) 아이콘 클릭 -> 해당 상품 구매여부 조회 -> 각 테이블에 insert -> Count로 좋아요(싫어요) 개수 조회
==> 만약 좋아요를 눌렀다가 싫어요를 누르면 좋아요는 제거(delete)되고, 싫어요(insert)가 추가되야한다.
==> select -> delete -> insert

 
▶ prodView.jsp 문서가 로딩되는 순간 ajax 동기처리로 해당 물건을 구매했나 안했나를 파악한다.
==> IsOrderAction.java 를 이용해서 상세페이지의 제품번호와 유저아이디를 이용하여 주문 테이블과 주문상세 테이블에 검색되는 행이 있는지 파악해온다.

※ 동기처리인 이유는 문서가 로딩되자마자 반드시 먼저 실행되게 하기 위해서이다.
==> 만약 비동기처리면 처리하는 동안 다른 작업들이 실행되어져 버려서 isOrderOK 함수가 false로 넘어갈 수 있기 때문이다.

★ key point는 좋아요 테이블과 싫어요 테이블은 유저아이디와 제품번호로 복합 기본키를 만들었기 때문에 유저들은 한 제품에 좋아요와 싫어요를 한 번씩만 가능하다.

■  LikeAddAction.java, DislikeAddAction.java 
- 자바스크립트에서 좋아요와 싫어요 함수는 먼저 세션에 로그인유저가 비어있지 않아야 한다(== 로그인을 해야한다.)

- 어떤 제품에 대한 좋아요와 싫어요인지 알아야 하기 대문에 함수 호출시 pnum을 파라미터로 넘긴다.

- 각각의 함수들은 ajax로 Action을 호출하고 제품번호와 로그인한 회원의 아이디를 데이터로 전송해준다.

- 정상적으로 insert를 했다면 int 값을 반환한다.
==> 1이라면 정상투표, 0이라면 중복투표

■ ProductDAO.java

▶ 좋아요(싫어요) 아이콘 클릭 -> 해당 상품 구매여부 조회 -> 각 테이블에 insert -> Count로 좋아요(싫어요) 개수 조회
==> 만약 좋아요를 눌렀다가 싫어요를 누르면 좋아요는 제거(delete)되고, 싫어요(insert)가 추가되야한다.
==> select -> delete -> insert

좋아요 눌렀으면 해당 제품번호, 아이디로 싫어요 누른걸 먼저 지운다. ( 없는걸 삭제해도 SQL 오류는 안나니깐 괜찮다. )

그 다음에 좋아요에 insert를 한다.

delete와 insert가 정상적으로 됐다면 리턴값은 1이다.

만약 insert가 비정상적(중복투표)라면 SQLIntegrityConstraintViolationException 예외처리로 rollback을 시키고, 1이라면 커밋을 시킨다.

▶ LikeAddAction에서 리턴된 int 값에 따라 msg 를 주고 JSON 형식으로 만들어서 jsonview.jsp로 보낸다.

※ swal == alert

▶ 이제 좋아요 테이블과 싫어요 테이블을 각각 읽어와서 개수들을 표시해줘야 한다.
==> 제품번호만 가지고가서 이 제품번호에 대한 좋아요와 싫어요 개수(count)만 가져온다.

select ( select count(*) 
         from tbl_product_like 
         where fk_pnum = 3 ) AS LIKECNT,
       ( select count(*) 
         from tbl_product_like 
        where fk_pnum = 3 ) AS DISLIKECNT
from dual;

서브쿼리를 이용한 SQL문

=======================================================================

[ 리뷰 ]

[ 리뷰 테이블 ]
기본키 - 시퀀스
유니크키 - 아이디, 제품번호를 복합으로 걸면 리뷰는 한 번만 쓸 수 있다.

▶ insert - 아이디, 제품번호, 리뷰내용

[ AJAX 데이터 전송방법 ]

1. 자바스크립트 객체를 만들어서 {키:벨류} 쌍으로 넣는다.

2. POST면 폼으로 전송하니깐 .serialize()로 모든 값들을 뽑고 name을 키값으로 보낸다.

★ form태그의 선택자.serialize(); 을 해주면 form 태그내의 모든 값들을 name값을 키값으로 만들어서 보내준다. 
★ form태그의 선택자.serialize(); 는 jQuery의 함수이다.

1번과 2번은 똑같은 것이다. 만약 보낼 값이 별로 없다면 1번을, 많다면 다 쓰기 귀찮으니 2번을 쓴다.



▶ PurchaseReviewsVO 생성 

★ 한 제품당 구매후기는 한 번밖에 못쓴다.

DAO에서 리뷰목록을 List로 받아온다. 

List를 JSONArray로 만들어서 Ajax로 넘긴다.

$.each( ) 를 이용하여 문자열로된 JSONArray에서 요소를 하나씩 꺼내서 반복문으로 찍어준다.
==> ★ JSONArray는 $.each( )로 반복해서 요소를 꺼내온다.

만약 비회원이거나 작성자가 아니면 리뷰삭제버튼을 안보여주고, 로그인한 회원과 작성자가 똑같다면 리뷰삭제버튼을 보여준다.

json.length 가 0보다 크지 않다면 해당 제품에대한 리뷰가 없는 것이니 "등록된 리뷰가 없습니다."를 결과창에 꽂아준다.

▶ 지금은 리뷰등록버튼을 눌러야 함수가 호출되기 때문에 처음 상품상세에 들어가면 보이질 않는다.
그래서 문서가 실행되자마자 해당 함수를 실행시켜서 리뷰들을 가져온다.

▶ 리뷰삭제는 review_seq를 이용해서 삭제를 한다.
==> function delMyReview(review_seq)

DML이니 전송방식에 따른 조건절을 걸어준다. 
==> POST면 기능 수행
==> GET이면 비정상적인 접근이니 나가게 한다.

=======================================================================

[ 로딩화면 구현하기 ] 

https://www.w3schools.com/howto/tryit.asp?filename=tryhow_css_loader2