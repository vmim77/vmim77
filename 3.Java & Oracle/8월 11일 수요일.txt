08월 11일 오전수업

[ Lock ]

update이다. --> lock 걸린 것을 조심해야 한다.( Live Lock은 괜찮은데, Dead Lock은 치명적이다. )

※ Lock
update를 하고선 아직 commit을 안 한 행을 select는 가능하지만, update를 또 하려하면 lock이 걸려진다.
 
SQL> update jdbc_board set boardpasswd = 'abcd'
  2  where boardno = 5;

1 row updated.
==> 현재 Lock이 걸려진 상태이다.

update 등 DML을 하고선 commit을 안 한 행을 또 다시 DML을 하려하면, waiting(대기상태)에 빠져버리는데 이게 바로 'lock'이다.
==> 먼저 update 를 한 곳에서 commit을 해주면 바로 lock이 풀려진다.

==> Live Lock은 한 쪽에서 commit을 해주면, 다른 쪽에서 바로 lock이 풀려지니 치명적이진 않다.


※ Dead Lock

양쪽에서 두 개의 테이블을 교차로 DML을 하고 commit을 안하면, 서로 둘 다 Lock에 빠져버리는데 이게 바로 Dead Lock이다.

1번사용자 - A테이블 업데이트 (Lock)
2번사용자 - B테이블 업데이트 (Lock)
1번사용자 - B테이블 업데이트 (대기)
2번사용자 - A테이블 업데이트 (대기)

==> 이렇게 되는 경우 Dead Lock을 유발함

Dead Lock을 예방하는 방법은 자바에서 '수동Commit' 이 아니라, 'Auto Commit'을 사용하는 것이다.

update, delete가 lock에서 문제가 크다.
==> 서로 다른 유저가 같은 행에 대해 DML을 하면 Lock이 유발되어짐
==> 이러면 Waiting 상태에 빠짐
==> 먼저 DML을 한 유저가 commit을 해줘야 다른 유저들이 Waiting 에서 빠져나옴

==> 더욱 최악은 서로 다른 유저가 서로 다른 테이블에 DML을 하다가 겹쳐지면 Dead Lock이 발생한다.
==> 해결책은 Oracle 서버를 껏다 키면 된다.
==> 혹은 테이블에 LOCK 이 걸려진 세션을 찾아서 Kill Session을 하면 된다.

★ 안 걸리게 예방하는 법은 Auto Commit을 권장하는 것이다.
==> 부득이하게 수동 commit을 해야한다면 

=============================================================

[글수정하기]

자신이 작성한 글만 수정할 수 있게 해야한다.

본인이 작성한 글이면 '글암호'를 물어본다.
'글암호'가 맞으면 글수정하기로 넘어간다.

변경전 글제목, 글내용 쏴주고

엔터를치면 기존 내용을 사용하게 한다.

수동커밋

==> 내가 쓴 글인지, 남이 쓴 글인지 알아야 하니 현재 로그인 된 사람의 MemberDTO를 넘겨서 확인
==> 스캐너도 넘긴다.

파라미터를 넘길 때 그냥 넘겨도 되지만 Spring 등에서는 Map을 쓰니깐 Map을 사용해 파라미터를 메소드에 넘겨주자

이미 만든 메소드 중에 viewContents( ) 는 글 번호만 넣어주면 해당되는 글을 select 해준다.
==> 만약 존재하지 않는 글 번호라면 while문을 안돌려서 BoardDTO 객체를 메소드에서 안 만든다.

Lock을 예방하기 위해서 Auto Commit을 사용하여 수정여부를 사용자에게 안내한다.

==> 사용자가 수정하겠냐고 묻는데 Y를 누르면 수정한 글내용과 제목을 받아서 업데이트 시키고 자동으로 commit까지 하는 메소드를 만든다. (if절로 result가 뭐인지 확인하고 commit이 아니라 일단 commit을해서 dead lock 방지)

파라미터 = 변경할 글 번호(where절에 사용), 변경할 글제목, 변경할 글내용 들을 paraMap에 넣어줘서 보낸다.
※ 글번호는 처음에 맵에 넣은거 그대로 사용하면 됨, 어차피 똑같은 글 수정하는거니깐


★ 수동커밋이 반드시 능사는 아니다, 사용자들끼리 물리고 물리면 Lock을 유발시킴

=============================================================

[글삭제하기]

delete -- 수정하기랑 개념이 똑같다.

남의 글은 못 지우고
내가 쓴 글이면 --> 암호를 입력받고 --> 암호가 맞아야 --> 삭제해줌
                                              --> 암호가 틀리면 --> 삭제불가능
※ 댓글이 딸린 글은 댓글까지 삭제시켜야 한다.
※ 댓글테이블에 foreign key가 on delete cascade로 되어져있다. 삭제 가능
그러니깐 원글만 지우면 동시에 알아서 댓글들도 삭제된다.

foreign key에서 on delete cascade는 어떨 땐 사용하는게 낫다.
(업무 프로세스에 맞게 사용해야 한다.)

==> 책 반납에서는 사용하면 안 된다. 
==> 20권 반납할 때 반드시 20권 동시에 반납하는게 아니라, 18권만 반납할 수 있으니깐
==> 근데 반납테이블에서 삭제해버리면 반납 안 한 책도 사라짐

=============================================================

[최근 1주일간 일자별 게시글 작성건수]


============================================================

미니 프로젝트

★ DAO에 close( ) 메소드 만들고 다 추가하기 (완료)
★ 글 수정하기 오늘 수업내용처럼 수정
★ SQL 익셉션 처리되면 에러메시지 나오게 메소드 수정
★ 도서검색 코드 공유하기
★ eXERD 대여상세테이블 변경한거 알리기


도서 대여하기 

도서대여메뉴 

1. 전체도서보기
2. 대여하기 ---> select --> DTO 넣고 --> 대여테이블 insert & 도서테이블 delete

-- 대여테이블 시퀀스 생성(seq_lend)
-- 대여테이블에서 adminid 컬럼 삭제
-- 대여테이블에서 lend_date 컬럼 default sysdate로 변경 

-- 대여상세테이블 시퀀스 생성(seq_lend_d)
-- 대여상세테이블 return_date 컬럼 default sysdate +7 로 변경
 
-- 연체테이블 시퀀스 생성(seq_yeonche)

tbl_book, lend_detail, tbl_yeonche

Table TBL_BOOK이(가) 생성되었습니다.(fk_isbn, status)
Table LEND_DETAIL이(가) 생성되었습니다.(lend_d_code, fk_lend_code, fk_isbn, return_date)
Table TBL_YEONCHE이(가) 생성되었습니다.


둘 다 성공 == 1
첫번째 실패 == 2
두번째 실패 == 3

 ORA-02291: integrity constraint (MINIORAUSER8.FK_LEND_DETAIL_CODE_FK_BARCODE) violated - parent key not found


도서반납하기

내가 빌린 도서들 출력

--> 반납하실 책을 선택 
--> 해당select --> DTO
--> 대여테이블 delete
--> 도서테이블 insert


do{
스캐너 ISBN 

조회(ISBN으로 있는 책인가 검색)
 
======================================
if(검색한 책이 있는거면 && 채번 == 0)
메소드 {

채번

삽입(대여테이블)

};
======================================

삽입(대여상세테이블) - 대여번호(fk_lend_code <== 채번한거 넣음, ISBN <== 스캐너값 넣음) X20

삭제(도서테이블) -- 도서 테이블 ISBN 

갱신(도서상세테이블) -- ISBN 검색해서 상태컬럼 갱신
commit

더 빌릴래요
} while(그만빌릴래요);


=============================================================


1. 전체 책 목록 출력 (완)
2. 스캐너로 ISBN 입력받는다. (완)
3. 조회(select tbl_lib where lsbn = ?) (완)
4. 채번(완)
5. 삽입(대여 테이블) --- 1번만
6. 삽입(대여상세 테이블) --- 한번에 빌리는 책 갯수만큼

7. 도서테이블에 스캐너로 입력받은 ISBN의 책 삭제(delete)
8. 도서상세테이블에 스캐너로 입력받은 ISBN의 책 상태 1로 변경(update)




=============================================================

▶ 테이블들 필드 타입, 유효성 확인하기
▶ eXERD 최신화하기
▶ 코드 문법 확인하기

도서상세 bookno컬럼 생성 

도서상세 시퀀스 생성 
==> 도서테이블에서 빌리는 책을 삭제해야하는데, 대여상세가 foreign key로 되어있어서 삭제 불가능
==> 그래서 PK이자 FK인 fk_isbn을 PK를 삭제하고, PK용 bookno컬럼 생성, fk_isbn 은 on delete cascade로 재생성, unique 제약조건을 줌

도서상세 시퀀스 - seq_tbl_book

★ lend_detail isbn 포린키 제약 삭제 --> 도서테이블 삭제하기 위해서
