08월 09일 오전수업

[ 글목록보기 구현 ]
글번호, 글제목, 작성자, 작성일자, 조회수
글제목은 길면 몇 글자만 짜르고 이후에는 ... 으로 표시

모두 select해서 조회할 것이여서 파라미터는 필요없다.(== where절이 필요없다.)
BoardDAO로 가야한다.

여러 행을 가져와야 하니깐 List 타입으로 메소드를 설정한다.(BoardDAO 메소드)
※ 프로시저로 여러 행을 받아올 때는 SYS_REFCURSOR를 이용한다.
※ 지금은 그냥 select로 받아오니깐 List를 사용한다.

※ DQL문은 .executeQuery( ) 

while(rs.next()) 문으로 돌때마다 BoardDTO 객체를 만들어서 select된 한 행의 내용을 BoardDTO에 넣어준다.
BoardDTO에는 작성자명의 필드가 없는데 어떻게 넣는가? ( MemberDTO의 필드인데 JOIN해서 사용하려면? ) ==> 리턴타입은 게다가 BoardDTO인데 어떻게 MemberDTO의 필드값을 넣을까?

BoardDTO는 MemberDTO에서 userid를 가져오는 자식테이블 이니깐, MemberDTO의 필드를 select용으로 BoardDTO에 만들어준다.
==> 자식테이블에서 부모테이블을 넣어준다.
------------------------------------------------------
[ 예시 ]
MemberDTO member = new MemberDTO();			
member.setName(rs.getString(3));
bdto.setMember(member);
------------------------------------------------------

만약에 m.name, m.point, m.mobile 이 JOIN되어 사용된다 해도,
member객체에 setter로 넣어준 다음에 이 member객체를 BoardDTO에 넣어주면 된다.

※ List는 한 행씩, 한 행씩 넣어주는 배열인데 최대값이 무제한이다.


List<BoardDTO> boardList 은 만약에 select된게 없다면(글 쓴것이 하나도 없다면), while문이 작동을 안하는데 그러면 알맹이가 없는 List를 리턴시켜준다.
그래서 if문을 이용하여 알맹이가 있다면 출력을 시켜준다.
==> 알맹이가 없어도 new ArrayList( ); 를 했기 때문에 NULL이 아닌 0이다.

넣어줄땐 member를 다 넣어주고, 출력할땐 member.getName() 만 한다.

==================================================================

[ 글내용보기 구현 ]

특정글 보기 (select where)

보고싶은 글번호 선택 후

글내용
댓글

식으로 출력한다.

근데 글내용을 보면 조회수가 자동적으로 올라가야 한다.
(select + update의 트랜잭션 처리를 해야한다.)
(※ 내가 쓴 글을 내가 보면 조회수가 올라가면 안 된다.)

파라미터 
1. 스캐너 - 글번호 선택시켜야 함
2. MemberDTO.getuserid() - 현재 로그인한 사람의 정보 넘겨서 글작성자 != 로그인한 회원 이여야 조회수 update 해준다.


[ 예시 ]
로그인 -> 게시판가기 -> 글내용보기
 
만약에 현재 로그인이 'leess'이라면, 

보고싶은 글번호를 물어보고, 글을 가져오는데(select where) 만약 로그인한 사람(leess)과 select되어져온 테이블의 fk_userid가 같은지 물어보고 같으면 update를 안하고, 다르면 update를 해준다.  

※ 나중에 글 수정하기, 삭제하기를 할땐 글 암호를 확인하고 시켜줘야 하니깐, 글 수정하기, 삭제하기를 위해서 글암호까지 가져온다.

왜 스캐너로 입력받은 글 번호를 DAO에 넘겨줄때 Map에 담아줘서 보낼까?
==> 나중에 Spring 에서는 다른 메소드를 호출해서 파라미터에 담아서 보내줄때는 Map을 활용하기 때문에 미리 익숙해지려 사용하는 것입니다. 

조회한 글이 없으면 NULL을 리턴해줄 것이다.

if(bdto != null) { 
// 존재하는 글번호를 입력한 경우
System.out.println("[글내용] " + bdto.getContents());


// 로그인한 아이디가 작성자 아이디와 다르면 조회수 UPDATE
// 로그인한 아이디가 작성자 아이디와 같으면 업데이트 안합니다.
			
}
else {
// 존재하지 않는 글번호를 입력한 경우
			
}


고유한 값인 글번호를 파라미터로 보내서 해당 글만 UPDATE를 해준다.
==> 입력받은 글번호를 보내준다.

==================================================================

[ 댓글쓰기 ]

댓글쓰기 = insert / 테이블이 jdbc_comment이다.

몇 번 글에 댓글 쓸래? ==> 스캐너 필요
댓글 쓴 사람 아이디 ==> 현재 로그인한 사람 MemberDTO member

글쓰기와 대동소이하다.

n == 1: 댓글쓰기 성공(commit)
n == 0: 댓글쓰기 취소(rollback)
n == -1: 원글번호가 없는 번호임(SQLException)


[ 스토리보드, 청사진, ProtoType ] 
>> 댓글쓰기 <<
1. 작성자명 : 엄정화 ==> 작성자명은 자동적으로 로그인 되어진 사용자 이름이 나오도록
2. 원글의 글번호 : 
3. 댓글 내용 : 
>> 댓글쓰기 성공!! <<

댓글내용이 공백만으로 된 경우 혹은 그냥엔터면 안 받아 줄 것이다.


bdao.writeComment(cmdto, sc);
cmdto ==> 댓글 내용들
sc == > 커밋확인


userid 만큼은 로그인 한 사람이 들어가서 foreign key 참조오류가 발생 안 한다.
허나 boardno를 없는 번호를 넣었다면 foreign key 참조오류가 발생한다. (제약조건 위배)


catch(SQLIntegrityConstraintViolationException e) << 제약조건이 위배된 것은 이곳에 떨어진다.
※ catch(SQLException e)에도 떨어지나, 배운 것이여서 위에 것을 사용한다.

==================================================================

08월 09일 오후수업

※ 오후 2시부터 미니프로젝트 시작

DB서버 IP : 211.238.142.82
USERID / PASSWD : miniorauser8 / cclass

테이블은 한 명이 만들어야 한다.
>> 나머지는 공유 받는 것

-- 도서 테이블입니다.
select *
from tbl_lib;

-- 회원 테이블입니다.
select * 
from tbl_member;

-- 대여 테이블입니다.
select *
from tbl_lend;

장르 5개 -- 각각 4개씩 -- 총 20권 
(책번호, ISBN, 책이름, 작가, 출판사, 장르, 상태, 코드, 수량)
1. 소설 - 1만번대
2. 에세이 - 2만번대
3. 경제경영 - 3만번대
4. 과학 - 4만번대
5. 역사 - 5만번대 

===============================
국가번호[대분류]
1(한국)
2(외국)
===============================
장르번호[중분류]
A(소설)
B(에세이)
C(시)
===============================
D(외국소설)
E(외국경제경영)
F(외국과학
===============================
1(한국) || A(소설) || 001(소분류) AS 분류
2(외국) || D(외국소설) || 006(소분류) AS 분류
===============================

★ 도서대여히스토리 

=========================================================

★ DB모델링 피드백

[ 도서 테이블 ] : 바코드 필요없음,  ISBN만 있으면 된다.(고유값임)

[ 도서 테이블 ] 에 도서명, 저자, 출판사까지 넣어준다.

국가코드, 중분류코드, 소분류코드가 [도서테이블]과 연결될 필요 X
==> 소분류만 [도서테이블]과 연결

소분류 코드(다) <----- 중분류코드(일)
중분류 코드(다) <----- 국가코드(일)

[도서 테이블]에 가격 추가

이제 [도서 테이블]에 한 권의 책이 우리 도서관에 여러권 비치되어진 것이다.
[도서 테이블] (일) ----> [도서상세정보] (다)

[도서상세정보]에서 수량은 필요X
==> 이 책이 몇권있는지는 select count(*) from 도서상세정보
==> ISBN은 같은 책끼린 똑같다

★ [대여] 가 잘못됨
==> 한 번 도서관가면 20권 빌려옴
==> 대여번호가 primary key이면 안 됨
==> 대출여부 필요없음
==> 회원아이디(누가빌림?), 관리자아이디(누가빌려줌?)

==> 한 사람이 20권을 빌리면 대출일자, 반납일자, 빌린사람, 빌려준사람이 중복됨 (정규화 필요)

101 08/09 08/16 먼나라이웃나라1 이순신 관리자
102 08/09 08/16 먼나라이웃나라2 이순신 관리자
103 08/09 08/16 먼나라이웃나라3 이순신 관리자
.....

101 이순신 관리자 <<- 
102 엄정화 관리자2 

1 101 책바코드1 반납예정일자
2 101 책바코드2 반납예정일자

3 102 책바코드3 
4 102 책바코드4
5 102 책바코드5


==> 대여번호는 다르지만 뒤쪽은 다 중복됨
==> 제 1정규화에 위배됨


[회원](일) ----> [ 대여 ](다)  : 대여번호(PK), 아이디, 대여일자
[대여](일) ----> [ 대여상세 ](다) : 대여상세일련번호(PK), 대여번호(FK), 바코드(FK)

반납예정일자는 [대여상세]로 빼는게 편하다.
==>  반납은 대여에 insert가 되어진 것을 지우는 것이다.(delete)
==>  20권 빌려갔는데, 18권만 반납함
==>  2권을 연체했는데 각각 연체날짜가 다르면, 대여에서 delete하면서 연체된걸 연체 테이블에 insert해준다.
==> 자식에서 아직 연체중인 책 한권을 안 지워서, 부모에서 이 대여번호를 못 지운다.
==> 연체된 책까지 모두 반납해주면 자식테이블에는 부모테이블의 대여번호가 없으니 부모테이블에서도 101번 행도 삭제 가능

연체는 대여상세정보에서 삭제된게(반납예정일정에서 지난 다음에 삭제된것) 연체로 들어오는 것이다.




alter table 테이블명 add constraint 제약조건명 primary key(컬럼명);
alter table 테이블명 add constraint 제약조건명 unique(컬럼명);
alter table 테이블명 add constraint 제약조건명 check( ... );

alter table 테이블명
rename column 현재컬럼명 to 새로이변경할컬럼명;

alter table 테이블명
modify 컬럼명 새로운데이터타입;

alter table 테이블명 
add 추가할컬럼명 데이터타입


ALTER TABLE '테이블명' DROP CONSTRAINT '제약조건명';


