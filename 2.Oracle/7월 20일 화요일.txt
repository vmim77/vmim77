07월 20일 오전수업

[ 정년퇴직일 구하기 ]

정년퇴직일은 63세가 되는 년도이다. 
현재 나의 나이가 몇 인지 확인한다.
add_months( sysdate, (63-내 나이)*12 )
to_char( add_months( sysdate, (63-V.현재나이)*12 ), 'yyyy' )
==> 이 사람이 몇년에 정년퇴직인지 알 수 있다.

이제 3~8월 생들은 8월 31일을 붙이고, 9~2월 생들은 2월 말을 붙여준다.
|| case when to_number(substr(V.주민번호, 3, 2)) between 3 and 8 then '-08-01'
else '-02-01' end

그리고 정년퇴직 연도와 붙여준 것을 last_day 를 이용해 말 일을 부여해준다.
to_char(last_day(to_date(to_char( add_months( sysdate, (63-V.현재나이)*12 ), 'yyyy' ) || case when to_number(substr(V.주민번호, 3, 2)) between 3 and 8 then '-08-01'
else '02-01' end, 'yyyy-mm-dd')), 'yyyy-mm-dd')

** inline view에서 별칭(예 : V)은 생략 가능하다.

=====================================================================

[ 정년퇴직일까지 근무개월수 구하기 ]

** months_between 에는 날짜타입이 들어가야 한다.

정년퇴직일까지 담겨진 select 문을 다시 view로 만들어서 테이블화 시킨다.

** 정년퇴직일을 V의 FROM에 넣을 수 없는 이유는, 현재나이와 주민번호를 받아서 와야하는데 넣어버리면 현재나이와 주민번호 필드를 받아올 수 없기 때문에 정년퇴직일을 구할 수 없다.
** from -> where -> ~~~~ -> select 순서로 구동하니, from 에 넣어버리면 정년퇴직일은 현재나이와 주민번호 필드를 받을 수 없다.

-----------------------------------------------------------------------------------------------------------------

★★★ SQL, Java 모두 중복성을 제거하고, 가독성을 높혀야 한다.

trunc(months_between(last_day(to_date(to_char(add_months(sysdate, (63-현재나이)*12), 'yyyy') ||
case when to_number( substr(주민번호, 3, 2) ) between 3 and 8 then '-08-01'  
else '-02-01' end, 'yyyy-mm-dd')), 입사일자)) AS 정년까지근무개월수

==> 전자보다는 

trunc(months_between(정년퇴직일, 입사일자)) AS 정년까지근무개월수 

==> 후자가 더욱 보기가 좋다.

-----------------------------------------------------------------------------------------------------------------
★★★ select의 처리 순서는 from -> where -> group by -> having -> select -> order by 순서다.

=====================================================================

[ 예상 퇴직금 구하기 ]

퇴직금 => 정년까지 근무년수 * 월급            26개월 ==> 2년 2개월 ==> 2년*월급
trunc( trunc(months_between(정년퇴직일, 입사일자)) / 12 ) * 월급 )

=====================================================================

[ 대출납부 테이블 만들기 ]

이자납부일이 만약에 '토요일' 이라면 다음주 '월요일'에 납부하도록 한다. ==> '10'일 납부자
이자납부일이 만약에 '일요일' 이라면 다음주 '월요일'에 납부하도록 한다. ==> '25'일 납부자

이번달납부일을 to_char(날짜, 'd') 로 해서 주말이라면, 다음주 월요일이 납부일이 되도록 날짜 형에 더하기 일수를 해준다.

▶ inline view 를 사용하여 작성해야 가독성이 높아지고, 유지보수가 높아진다.

** 대출금과 이자율은 똑같아도, 빌려쓴 기간은 다르기 때문에 이번달이자금액은 서로 다르다.

★ from 에 있는 필드를 써야 select 에서 임의로 추출하고, 변경시켜서 새로운 필드를 만들어서 출력할 수 있다.
★ 그 필드를 가독성 좋게 다시 호출해서 임의로 변경하고 추출하려면 다시 한 번 inline view 로 감싸면 된다.

이번달이자금액 ( 실제이번달이자납부일, 실제지난달이자납부일 (이번달이자납부일, 저번달이자납부일) )

=====================================================================

[ 특정 글번호의 게시글만 추출하기 ]

기존 select 문에 where boardno = 3; 만 한다면, 메모리에 3번글만 올리기 때문에 이전글번호 / 다음글번호가 NULL로 출력된다.

그래서 먼저 5개의 게시글을 모두 메모리에 올린 다음에, 후에 글번호가 3번인 것만 추출해야 한다.

★ decode 는 null 을 비교해서 찾을 수 있다.
★ case when then else end 는 null 을 비교해서 찾을 수 없다.

stored view 를 사용하면 select 구절에서 만든 필드도 where 조건에 넣어서 원하는 행만 추출할 수 있다.

★ 오라클은 테이블네임, 컬럼네임, 뷰네임은 디폴트로 대문자로 본다.
>> 조회할 때는 대문자로 써야한다. 
>> 데이터값만큼은 대/소문자 구분한다.

=====================================================================

[ 과제 ]

[문제 1] --- 완
employees 테이블에서 부서번호 30번, 50번에 근무하는 사원들만 
부서번호, 사원명, 주민번호, 성별을 나타내세요.
성별은 '남' 또는 '여'라고 나타낸다. 그리고 주민번호는 생년월일만 기재해주고 나머지는 마스킹('*')처리해서 보여준다.

[문제 2] --- 완
employees 테이블에서 90번 부서에 근무하는 사원들만 아래와 같이
사원명, 공개연락처, 비공개연락처를 나타내세요.
여기서 비공개연락처란? 국번을 * 로 마스킹처리 한것을 말한다.

[문제 3] --- 완
employees 테이블에서 80번 부서에 근무하는 사원들만 아래와 같이
사원명, 공개연락처, 비공개연락처를 나타내세요.
여기서 비공개연락처란? 첫번째 국번과 마지막 개별번호를 * 로 마스킹처리 한것을 말한다.

[문제 4] --완
employees 테이블에서 80번, 90번 부서에 근무하는 사원들만 아래와 같이
부서번호, 사원명, 공개연락처, 비공개연락처를 나타내세요.
여기서 비공개연락처란? 첫번째 국번과 마지막 개별번호를 * 로 마스킹처리 한것을 말한다.

-- email : tjdudgkr0959@naver.com
-- 메일제목 : SQL과제_1_자기이름
-- 첨부파일 : SQL과제_1_자기이름.txt
-- 기한 : 2021.07.21 (수) 14:00

=====================================================================

07월 20일 오후수업

[ 그룹함수 == 집계함수 ]

1. sum          -- 합계
2. avg           -- 평균
3. max          -- 최대값
4. min          -- 최소값
5. count        -- select 되어서 나온 결과물의 행의 개수
6. variance     -- 분산
7. stddev       -- 표준편차

★ 그룹함수는 결과물이 1개만 나온다.
★★★ 그룹함수(집계함수)에서는 null 이 있으면 무조건 null 은 제외시킨 후 연산을 한다.

★★★ 사칙연산에 null 이 포함되어지면 결과값은 무조건 null 이다.

★★★ avg(평균)을 구할 땐 주의를 요한다.

수당이 NULL이 아닌 사원들만의 수당의 평균치인지 (분모 35) ,
모든 직원들에 대해 수당의 평균치인지 (분모 107)

확실히 기준을 정해놓고 avg를 구해야한다.

=====================================================================

[ group by 절 ]

▷ group by 절은 각 그룹 조건에 맞게 그룹화되면서 출력되는 행수가 바뀌지만,
▷ partition by 절은 출력되는 행수가 바뀌지 않고 모두 출력한다.

★ 없는 필드는 inline view 를 이용해서 만든다.
** group by 또한 order by 처럼 2차정렬이 가능하다.

=====================================================================

[ rollup, cube, grouping ]

▷ rollup : 그룹별 결과 뿐만 아니라 총 집계도 해준다. 
==> rollup 을  사용하면 행이 한 개가 더 추가된다.
==> 각 그룹별 사용한 집계함수의 총 값을 보여준다.
==> rollup 을 씌우면 자동으로 첫번째 컬럼기준으로 오름차순 정렬이 된다.
==> group by rollup(department_id)
==> 첫번째 컬럼에 나온 null은 그룹을 안 지었음을 뜻한다, 그룹을 안지었을때 총 집계함수 값을 보여준다.
★ 누적에 대한 총계를 구할 때 주로 사용한다.

롤업을 두개로 하면, 먼저 1번 그룹의 누적 총계를 나타내고, 1번에서 나눠놓은 그룹별 2번 그룹의 누적 총계를 나타낸다.

▷ cube

★ grouping 함수는 rollup 이나 cube가 쓸 때만 쓰는 것이다.
>> grouping 함수는 항상 값이 2개이다. ( 0 아니면 1 )
>> 그룹화가 되었다면 0을 출력하고, 그룹화가 안됐으면 1을 출력한다.
>> select 구절에 그룹화에 쓰인 필드명을 grouping( department_id ) 로 적는다.

** 한 컬럼에 숫자와 문자를 동시에 쓸 수 없다.


