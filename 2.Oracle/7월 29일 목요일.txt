07월 29일 오전수업

[ 복합인덱스(Composite Index) ]

두 개 이상의 컬럼을 가지고 하나의 인덱스를 만드는 것이다.

※ 선행컬럼을 잡는 것이 가장 중요하다.
==> 선행컬럼으로 선정되는 기준은 where 절에 가장 많이 사용되며, 선택도가 높은 컬럼이다.

선행컬럼만 단독으로 실행계획을 보면 인덱스를 사용하고,
뒤의 컬럼의 실행계획을 보면 인덱스를 사용하지 않는다.
==> where 절에 선행컬럼이 나와야 복합인덱스를 사용할 수 있다.

* user_ind_columns 의 column_position은 선행컬럼이 무엇인지 알려준다.

※ 만약에 둘 다 where 절에서 사용빈도가 똑같다면, 그 다음에는 선택도(고유한 정도)가 높은 컬럼을 선행컬럼으로 선택해야 한다.

==> '인덱스를 어떻게 만들 것인가?' 를 고민해봐야 한다. 그렇다고 인덱스가 많다고 좋은 것은 아니다. SELECT야 빨라지지만, DML 속도는 떨어진다. 

웹사이트를 기준으로,

로그인은 select가 많고,  ==> 로그인 성공 후 이름은 공개를 많이할테니 ID/PASSWD/NAME은 묶어서 복합인덱스를 만드는 것이 낫다는 것을 판단한다.

회원가입은 insert가 많다.
회원탈퇴는 delete가 거의 없다.
회원정보 수정은 update가 그리 많지 않다.

** 복합인덱스도 컬럼이 많아질수록 조회 속도가 상당히 떨어진다. 
** 반드시 필요한 컬럼만 복합인덱스로 만들어야 한다.

★ DML별 인덱스가 있을 시 단점 다시 읽어보기

==================================================================

[ 함수기반 인덱스(Function based Index) ]

select를 할 때 오라클 함수를 사용하여 조회를 할 수 있다.
where 절에 매번 함수로 써서 조회를 한다면, 인덱스를 만들 때 컬럼에 그 함수를 써서 쓴다.

ex)
    create index idx_func_tbl_student_1_name
    on tbl_student_1( substr(name, 2, 2) );

==================================================================

** = 기호가 아니라, like 연산자여도 똑같이 인덱스를 사용한다.
==> wild character를 어떻게 사용하냐에 따라서 인덱스 사용 혹은 Table Full Scan을 한다.

where name like '배수지%';    ==> 인덱스 사용
where name like '%배수지%'; ==> Table Full Scan

맨 앞에 % 또는 _ 가 나오면  Table Full Scan 하여 조회해온다.

==================================================================

[ 데이터 사전 ]

Oracle Data Dictionary View 라고 부른다.

DBA_로 시작하는 것은 관리자만 조회 가능한 것으로 모든 오라클 정보, 모든 테이블 등.. 모든 정보가 다 들어가져 있다.

USER_로 시작하는 것은 오라클서버에 접속한 사용자 소유의 자신의 정보들이다.

ALL_ 는 자기소유 + 내꺼는 아니지만 접근권한이 있는 모든 것을 보여준다.

SYS 계정으로 select * from dba_tables; 를 하면 첫번째 컬럼의 owner가 뜬다. 이유는 관리자는 모든 사용자를 다 볼 수 있기 때문이다.

==> 작업하다가 테이블에 대한 정보나 시퀀스, 인덱스에 대한 정보를 보려는데 뭘 FROM 절에 넣어야하는지 긴가민가하면 dict를 사용하면 된다.

==> 테이블에서 보여지는 컬럼에 대한 설명을 보고 싶다면 dict_columns이다.

==================================================================

[ PL/SQL ]

프로시저를 만든 다음에 출력된 결과를 보려면 '보기탭 -> DBMS 출력'을 눌러서 봐야한다.

★ select 되어진 정보들은 반드시 변수에 담아야 한다.

디버깅은 sqlplus에서 하는게 편하다 

==> 실행은 '/'로 한다.
==> 에러 확인은 show errors

(예시)
15/9     PL/SQL: SQL Statement ignored
21/60    PLS-00201: identifier 'V_AGE' must be declared
22/9     PL/SQL: ORA-00904: : invalid identifier
30/9     PL/SQL: Statement ignored
30/111   PLS-00201: identifier 'V_AGE' must be declared

행/열 번호를 확인해서 디버깅을 한다.

정상적이라면 Procedure created. 로 나온다.
==> create(DDL) 이여서 auto commit

변수의 실행부에서 원래 테이블의 컬럼 원형대로 들어오는 것은 파라미터나 변수선언에서 데이터타입을 그 테이블 컬럼의 원형과 똑같다고 줄 수 있다.
==> (p_employeeid IN employees.employee_id%type) 파라미터 선언
==> v_employee_id employees.employee_id%type;     변수 선언

==================================================================

07월 29일 오후수업



[ 레코드 타입 ]

레코드형 타입을 새로 만들어서 행 형식으로 출력하는 변수를 만든다.

-- record 타입 생성 --
type myEmpType is record
(employee_id employees.employee_id%type  
 ,ename       varchar2(50)
 ,gender      varchar2(10)
 ,monthsal    varchar2(15)
 ,age         number(3)
);

==> 이렇게 구성되어진 하나의 행을 만든다.
==> 그리고 변수 선언에서 이 행 타입으로 선언해준다.

select 되어진 결과물을 v_rcd에 넣고 컬럼들을 하나하나 추출해온다.



==================================================================

[ 사용자 정의 함수 ]

[문법]
create or replace function 함수명
(파라미터명  IN  파라미터변수의타입)
return 리턴되어질타입

is
    변수의 선언;
begin
   실행문
   return 리턴되어질값;
end 함수명;

select 구절에서 자주 사용되어지는 컬럼 변환을 함수로 만들어서 간편하게 호출해서 사용할 수 있다.
(ex. 나이 구하기, 성별 구하기 등)

어떤 변수에 넣을 때 select into 식도 괜찮고, 변수명 := 로 해도 괜찮다.

==================================================================

[ 제어문(IF 문) ]

    ※ 형식
    
    if      조건1   then 실행문장1;
    elsif   조건2   then 실행문장2;
    elsif   조건2   then 실행문장3;
    else                실행문장4;
    end if;

==================================================================

[ 사용자 정의 익셉션처리 ]

사용자가 정의해주는 Exception 에 대해서는 오류번호를 -20,001 ~ -20,999 까지만 사용하도록 오라클에서 비워뒀다.

==================================================================

[ 반복문 ]
반복문에는 종류가 3가지가 있다.
        
1. 기본 LOOP 문
2. FOR LOOP 문
3. WHILE LOOP 문

[1. 기본 LOOP문]

[문법]

LOOP
   실행문장;
EXIT WHEN 탈출조건;     -- 탈출조건이 참 이라면 LOOP 를 탈출한다.
END LOOP;

==================================================================

[ 익명 프로시저 ]

-- 이름이 있는 프로시저는 create or replace ~ 로 만든 다음에, 매번 이름으로 호출한다.

-- 이름이 없는 프로시저는 1회용이다.

[문법]

declare
 -- 변수 선언 및 초기화
begin
 -- 실행문
end; 
