07월 28일 오전수업

[ 자식테이블과 부모테이블의 제약조건 조회 합치기 ]

user_constraints 에서는 컬럼명은 나오지 않는다.

자식테이블의 user_constraints.constraint_name 과 자식테이블의 user_cons_columns.constraint와 join 하고,
자식테이블의 user_constraints.r_constraint_name 과 부모테이블의 constraint_name과 join 한다.

자식테이블 user_constraint + 자식테이블 user_cons_columns + 부모테이블 user_cons_columns (where 조건은 자식테이블의 r_constraint_name 과 부모테이블의 constratin_name 과 같은 것)

★ 면접에서 주로 제약조건 조회하기와 JOIN을 아는지 동시에 알려고 출제하는 문제이다.

==================================================================

[ 어떤 테이블에 제약조건 추가하기 ]

복사된 테이블에는 원래 테이블의 제약조건에서 NOT NULL만 복사된다.
또한 제약조건명을 지정해준 NOT NULL은 기본형인 'SYS_C~~~'식으로 이름이 바뀐다.

-----------------------------------------------------------------------------------------------------------

[ NOT NULL 제약을 제외한 제약조건 추가하기 ]

alter table 테이블명 add constraint 제약조건명 primary key(컬럼명);
alter table 테이블명 add constraint 제약조건명 unique(컬럼명);
alter table 테이블명 add constraint 제약조건명 check( ... );
       
alter table 테이블명 add constraint 제약조건명 foreign key(컬럼명) references 부모테이블명(식별자컬럼명);
alter table 테이블명 add constraint 제약조건명 foreign key(컬럼명) references 부모테이블명(식별자컬럼명) on delete casecade;
alter table 테이블명 add constraint 제약조건명 foreign key(컬럼명) references 부모테이블명(식별자컬럼명) on delete set null;

-----------------------------------------------------------------------------------------------------------

[ NOT NULL 제약 추가하기 ]

alter table 테이블명 modify 컬럼명 (제약조건명) not null;

==================================================================

[ 어떤 테이블의 제약조건 삭제하기 ]

alter table 테이블명 drop constraint 제약조건명;

그런데 NOT NULL 제약은 위의 것처럼 해도 되고, 또는 아래처럼 해도 된다.
alter table 테이블명 modify 컬럼명 null;

어떤 테이블에 primary key 제약조건을 삭제할 경우에는 위의 것처럼 해도 되고, 또는 아래처럼 해도 된다.
alter table 테이블명 drop primary key;

-----------------------------------------------------------------------------------------------------------

[ 어떤 테이블의 제약조건 변경하기 ]

문법이 따로 있진 않다.
기존 제약조건을 삭제하고서 내용이 변경되어진 제약조건을 추가하는 것이다.
-----------------------------------------------------------------------------------------------------------

[ 제약조건 이름 변경하기 ]

alter table 테이블명
rename constraint 현재사용중인제약조건명 to 새로운제약조건명

-----------------------------------------------------------------------------------------------------------

[ 어떤 테이블의 제약조건 비활성화 시키기 ]

alter table 테이블명
disable constraint 제약조건명
==> 삭제하는 것이 아니라, 잠시 안 쓰는 것이다.

※ 활성화는 disable을 enable로 바꾸면 된다.

==================================================================

[ 어떤 테이블에 컬럼 추가하기 ]

alter table 테이블명 
add 추가할컬럼명 데이터타입

이미 null 값이 들어가 있는 컬럼을 NOT NULL로 변경하려면?
==> 일단 null 값이 들어가 있는 컬럼들의 값을 임의로 ' ' 공백을 준다.
==> 그 후에 NOT NULL로 바꾼다.


alter table 테이블명 add 추가할컬럼명 데이터타입 default 기본값 NOT NULL;
==> 컬럼 추가하면서 NOT NULL을 동시에 부여하기

컬럼을 추가하고 NOT NULL 부여하는 방법은 2가지 이다.

1. 일단 컬럼을 추가하고, 임의로 컬럼값에 모두 공백을 주고, 그 후 NOT NULL 제약조건 부여한다.
2. 만들때 alter table 테이블명 add 추가할컬럼명 데이터타입 default 기본값 NOT NULL; 로 만든다.

-----------------------------------------------------------------------------------------------------------

[ 어떤 테이블에 컬럼 삭제하기 ] 

alter table 테이블명
drop column 삭제할컬럼명

-----------------------------------------------------------------------------------------------------------

[ 어떤 테이블에 컬럼명 변경하기 ]

alter table 테이블명
rename column 현재컬럼명 to 새로이변경할컬럼명;

-----------------------------------------------------------------------------------------------------------

[ 어떤 테이블에 존재하는 컬럼 데이터타입 변경하기 ]

alter table 테이블명
modify 컬럼명 새로운데이터타입;

==> 데이터가 없는 상태에서 변경하는 것은 문제가 없다.
==> 근데 데이터가 있는 상태에서 변경을 하면 오류가 뜬다.

==> 데이터 길이를 늘리는 것은 데이터가 있어도 가능하나, 원래있는 데이터보다 길이를 줄이는 것은 불가능하다.
==> 데이터가 있다면 그 길이보다 크게 줄여야 한다.

==================================================================

[ 어떤 테이블의 테이블명 변경하기 ]

rename 현재테이블명 to 새로운테이블명;

==================================================================

[ comment ]

테이블과 컬럼의 주석문이다.

테이블을 생성한 이후에 테이블명과 컬럼명에 대한 주석문을 반드시 넣기
==> 테이블이 워낙 많다보니깐, 테이블 이름을 다 기억할 순 없다.
==> 주석문을 달아주면 무엇을 위한 테이블이고, 컬럼명인지 알 수 있다.
==> 프로그래밍은 팀별로 운영되기 때문에 주석을 달아서 팀효율을 높일 수 있다.

-----------------------------------------------------------------------------------------------------------

[ 테이블명에 달려진 주석문 조회하기 ]

select* 
from user_tab_comments;

-----------------------------------------------------------------------------------------------------------

[ 테이블에 코멘트 달기 ]

comment on table 테이블명
is ' 코멘트 내용 ';

-----------------------------------------------------------------------------------------------------------

[ 컬럼 코멘트 조회하기 ]

select *
from user_col_comments;

-----------------------------------------------------------------------------------------------------------

[ 컬럼에 코멘트 달기 ]

comment on column 테이블명.컬럼명 is '내용';


==================================================================

[ 테이블 휴지통 ]

drop 시 purge를 안 붙이면 언제든 복구할 수 있다.

-----------------------------------------------------------------------------------------------------------

[휴지통 조회하기]

select *
from user_recyclebin;

-----------------------------------------------------------------------------------------------------------

[휴지통에 있던 테이블 복원하기]

flashback table 원래테이블명 to before drop;

-----------------------------------------------------------------------------------------------------------

[휴지통에 있던 테이블 영구 삭제하기]

purge table 원래테이블명;

-----------------------------------------------------------------------------------------------------------

[휴지통에 있던 모든 테이블 영구 삭제하기]

purge recyclebin;

-----------------------------------------------------------------------------------------------------------

[ 테이블 영구삭제 ]

drop table 테이블명 purge; 
==> Windows에 shift + delete와 같다.
==> 복구 불가능



==================================================================

07월 28일 오후수업

[ 계층형 쿼리 ]

-- 답변형 게시판 혹은 전자결재가 있는 그룹웨어에서 사용한다.


select level
   ,employee_id AS 사원번호
   ,first_name || ' ' || last_name AS 사원명
   ,manager_id AS 직속결재권자
from employees
start with employee_id = 104 
connect by prior manager_id = employee_id;

==> select level 은 평상시엔 못쓰고, 계층형쿼리에서만 가능하다.

==> 처음에는 사원번호 104번 행에 manager_id 값이 들어온다.
==> 즉 103이 들어온다.
==> 그 후에 104번과 103을 연결해주고, start with employee_id 에는 103이 들어간다.

connect by prior 103 = employee_id;
connect by prior 102 = employee_id;
connect by prior 100 = employee_id;
connect by prior null = employee_id; -- null 이여서 종료

★ prior 다음에 나오는 manager_id 컬럼은 start with 되어지는 행의 manager_id 컬럼의 값이다.

connect by prior employee_id = manager_id;
==>이렇게 위치가 바뀌면 상향식, 하향식으로 결과값이 뒤 바뀐다.
** 상향식은 가장 낮은 직급이 1레벨
** 하향식은 가장 높은 직급이 1레벨 

==> 자세한 내용은 답변형 게시판에서 강의할 예정이다.

==================================================================


[ INDEX ; 인덱스 ; 색인 ]

색인은 책 뒤에 나오는 "찾아보기"와 같은 기능을 하는 것이다.
"찾아보기"의 특징은 정렬되어 있는 것인데, index(==색인)에 저장된 데이터도 정렬되어 저장되어 있다는 것이 특징이다.

색인을 쓰는 이유는 where 절이 있는 select 명령문의 속도를 향상 시키기 위함이다.

[ 색인은 어떤 컬럼에 만들어야 하는가? ]

1. where 절에서 자주 사용되어진 컬럼에 만들어야 한다.

2. 선택도(selectivity)가 높은 컬럼에 만들어야 한다.
--> 고유한 데이터일수록 선택도가 높아진다.
--> 학번(아주 다양하다) > 성별(남, 여)
--> 학번은 선택의 여지가 아주 높다
--> 성별은 선택의 여지가 아주 낮다.

3. 카디널리티(cardinality)가 높은 컬럼에 만들어야 한다.
--> 선택도와 카디널리티는 거의 비슷하다.
--> 카디널리티는 상대적인 개념이지, 절대적인 개념은 아니다.
ex 성명은 "주민등록번호에 비해" 카디널리티가 낮다.
ex 성명은 "성별에 비해" 카디널리티가 높다.

--> 카디널리티↑ -- 중복도↓ -- 고유한 데이터 (ex 학번)
--> 카디널리티↓ -- 중복도↑ -- 중복이 많은 데이터 (ex 성별)

** tbl_ : table
** idx_ : index

unique index는 마치 Primary Key나 Unique 제약과 비슷하다.

unique index는 중복불가능
non-unique index는 중복가능

인덱스 유/무는 데이터가 별로 없을 땐 차이가 없어보이지만, 자료가 방대해지면 차이가 확연하다.

==================================================================

[ SQL Plan; 실행계획 ]

select 문이 실행될 때 인덱스를 사용하여 데이터를 얻어오는지, 인덱스를 사용하지 않고
Table Full Scan 하여 얻어오는지 알 때 사용한다. 

실행계획(Plan) --> 안 해보고 미리 예측
자동추적(Trace) --> 실행해보고 결과를 가져옴

자동추적이 실행계획보다 훨씬 정확하다.

또한, 실행계획은 말그대로 계획이라서 계획은 그렇게 세워졌으나, 실제 실행할때는 여러가지 이유로 다르게 실행할 수도 있다.

마지막으로 자동추적이 정확하기는 하나, 일단 한 번 실행을 해봐야 하는것이라서 시간이 오래 걸리는 SQL인 경우에는 한참 기다려야 하는 단점이 있다.

==================================================================

[ 자동추적 ]
* 자동추적은 권한을 부여받아야 할 수 있다. ( 관리자 SYS/SYSTEM 로 부터 받아야 함. )

결과물은 똑같지만 어떤게 더 나은지를 보려면 자동추적을 사용해서 
LAST_CR_BUFFER_GETS(읽어온 블록 갯수)와 LAST_ELAPSED_TIME(경과시간) 이 적어야 한다.

==================================================================

[ Index Rebuild ]

인덱스 리빌드 ==> alter index 인덱스명 rebuild;


인덱스가 있는 테이블에 insert 를 하면 인덱스 쪼개짐(index split)이 발생한다.
==> 그래서 항상 인덱스는 꼭 필요한 테이블에 만들어야만 한다.
==> DML이 빈번하게 발생하는 테이블에 인덱스가 생성되어져 있으면 DML 작업으로 인해 인덱스에 나쁜 결과를 초래한다.
==> 그래서 인덱스가 많다고 좋은 것이 아니니깐, 인덱스는 테이블당 최소한의 개수로 만드는 것이 좋다.


또한 delete를 해도 인덱스는 삭제되지 않고 사용을 안한다는 표시만 하게 된다.
예시로 10만 건이 들어있던 테이블에서 9만건의 데이터를 delete를 하면 테이블에는 데이터가 삭제되지만 인덱스 자리에는 10만 건이 그대로 있고, 1만건만 사용하고 9만건은 사용되지 않은채로 있어서 인덱스 속도가 떨어진다.
==> 이런 경우에는 Index Rebuild 작업을 해주어 사용하지 않는 9만건의 인덱스 정보를 삭제해줘야 select 해올 때 index 속도가 빨라진다.

update일때는 데이터는 수정되지만, 인덱스에는 수정이 없어서 delete를 하고 새로이 insert를 해준다.
그래서 index를 delete를 할 때의 단점과 index를 insert를 할 때 발생하는 인덱스 쪼개짐이 동시에 발생해서 최악의 상황을 맞게 된다.


==> 어떤 테이블이 있는데 DML 문이 빈번히 일어난다면 Index Rebuild를 해줘야 인덱스 속도가 다시 향상된다.



** 인덱스 삭제 ==> drop index 인덱스명;

==================================================================

어떤 컬럼에 Primary Key 또는 Unique 제약을 주면 자동적으로 그 컬럼에는 Unique 한 index가 생성되어진다.
인덱스명은 제약조건명이 된다.

그러므로 따로 인덱스를 만들 필요는 없다.
만약에 이렇게 자동으로 인덱스가 만들어진 컬럼 외에도 where 절에서 자주 사용하는 컬럼이 있다면 그 컬럼에 non-unique index를 주는 것이 좋지만, 허나 테이블에 인덱스가 많다고 무조건 좋은 것은 아니다.

Primary Key 또는 Unique로 자동 생성된 index의 제거는 drop index index명; 이 아니라,
제약조건을 삭제해야(alter table 테이블명 drop constraint 제약조건명) 자동적으로 index도 삭제된다.



내일 => 인덱스, 데이터 사전, PL SQL
