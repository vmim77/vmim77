08월 02일 오전수업

[ DB 모델링 ]

▶ eXERE 설치 ==> DB 모델링 도구

데이터베이스의 테이블 = 논리적인 모델링에서는 개체(Entity)
데이터베이스의 컬럼 = 논리적인 모델링에서는 속성(Attribute)
데이터베이스의 행 = 논리적인 모델링에서는 튜플(Tuple)
데이터베이스의 Unique key = 논리적인 모델링에서는 (후보)식별자
데이터베이스의 Primary Key = 논리적인 모델링에서는 대표식별자

▶ 자료에서 중복된 부분이 있으면 좋지 않다. 그래서 중복을 제거하려는 행위가 바로 '정규화'이다.
==> 고유한 식별자를 가지는 모든 개체(테이블)에 대해 더 이상 분리할 수 없는 상태로 나누는 과정을 말한다. 

정규화의 수준은 1~4정규화 & 역정규화가 있다. 정규화의 수준을 높히면 중복된 데이터를 제거하기 때문에 데이터량이 줄고, 데이터 갱신 속도(UPDATE)가 빠르며 같은 자료가 여러 개체에 분산된 것보다 일관성을 유지하기 쉽다.

그러나 자료를 합쳐서 봐야할 때는 JOIN 하여 작업해야 한다. 

==================================================================
[ 제 1 정규화 ]

어떤 테이블에서 중복된 값을 가지는 컬럼이 있다면 분리를 해서 새로운 테이블로 만든다. ==> 제 1 정규화
-- 중복된 부분인 개설과목(과목번호, 과목명, 교수번호, 교수명, 강의실코드, 강의실설명)은 '부모테이블'이며, 중복되지 않은 부분인 성적(학번,학생명,점수)는 '자식테이블'이다.
-- 제 1 정규화의 특징은 부모테이블의 식별자는 자식테이블의 외부키로 전이 되어진다.


예시에서는 같은 과목에 서로 다른 교수가 강의할 수 있어서 '과목번호, 교수번호'를 복합 기본키(Composite Primary Key)로 설정한다.
==> ★ 부모 테이블의 Primary Key는 항상 자식 테이블의 Foreign Key로 전이 된다.

==> 반복되어지는 속성들을 분리해서 새로운 테이블로 만든다.
==> 이것이 바로 '제 1 정규화' 이다.

==================================================================
[ 제 2 정규화 ]

제 2 정규화는 제 1 정규화를 마친 다음에 제 1 정규화의 식별자가 Composite Primary Key로 됐을 때만 제 2 정규화를 해야 한다.

개설과목 테이블에서는 과목번호, 교수번호가 Primary Key가 된다. 그러므로 제 2 정규화 대상이 된다.
성적 테이블에서는 과목번호, 교수번호, 학번이 Primary Key가 된다. 그러므로 제 2 정규화 대상이 된다.

제 1 정규화를 했는데 Single Primary Key라면 제 2 정규화는 없다.


비 식별자 컬럼이 식별자 전체에 대해서 의존적이라면 제 2 정규화를 할 필요 없으나, 비 식별자 컬럼이 식별자 일부에 대해서 의존적이라면 제 2 정규화가 필요하다.

교수번호가 바뀐다고 과목명이 바뀌진 않으나, 과목번호가 바뀌면 과목명이 바뀐다.

==> 과목명(비 식별자 컬럼)은 과목번호(식별자 일부)에 대해서만 의존적이니 새로운 테이블을 만든다.
==> 과목번호, 과목명으로 새로운 테이블을 생성한다.

==> 교수명 또한 식별자전체(과목번호, 교수번호)에 대해서 의존적이지 않고 식별자일부(교수번호)에 대해서만 의존적이다. 그러므로 분리해서 새로운 테이블을 만든다.


개설과목은 교수까지 준비된 과목이다.
과목은 교수가 배정되지 않은 과목이다.

강의실 코드는 과목번호, 교수번호에 전체에 대해서 의존적이다.( 누가 가르치는, 어떤 과목에 강의실 )
강의실 설명도 마찬가지이다.


성적 테이블에서 학생명은 학번에만 의존적이므로 제 2 정규화를 한다.
점수는 성적 테이블에서 과목번호, 교수번호, 학번에 전체적으로 의존적이여서 제 2 정규화를 하지 않는다. ( 누가 가르치는, 어떤 과목에, 누구의 점수인가? )
==================================================================

[ 제 3 정규화 ]

식별자가 아닌 컬럼이 식별자가 아닌 컬럼에 의존적이라면 분리해서 새로운 테이블을 만들어라
==> 개설과목 테이블에서 강의실 설명(식별자X)은 강의실 코드(식별자X)에 의존적이다.

==================================================================

어떤 과목 1개가 강의가 가능한 교수가 많다면(예시 오라클 기초 - A교수, B교수, C교수,....) 
==> 이 관계는 일 대 다(1:M) 라고 할 수 있다.
==> 일은 '부모 테이블', 다는 '자식 테이블'이다.


교수 또한 여러 개의 과목을 맡을 수 있다.

강의실 또한 여러 개의 과목을 할 수 있다. ( 오전에는 A 과목, 오후에는 B 과목 )

점선 식별관계 : Foreign Key만 된다.
실선 식별관계 : Foreign Key 이면서, 복합 Primary Key가 된다.

개설과목에서는 과목번호, 교수번호만 Primary Key면된다. ( 누가 가르치는, 어떤 과목 )


>> 정규화를 하면 할 수록 중복이 제거되며, 갱신을 할 때는 정규화 하기 전에는 매번 하나하나 찾아서 바꿔줬어야 했으나, 정규화가 완료되면 한 번만 바꾸면 다른 테이블들도 모두 갱신된다.

==================================================================
[ 제 4 정규화 ]

의존적인 다 대 다 관계를 제거하는 것이 제 4 정규화이다.

제 4 정규화를 이해하려면 테이블의 관계에 대해 알아야 한다.


한 고객은 여러 제품에 대해 주문을 할 수 있다. (1 대 다)
한 제품은 여러 고객에게 판매할 수 있다. (1 대 다)

즉, 고객 테이블과 제품 테이블은 '다 대 다 관계'이다.

그러나 논리적인 모델링에서는 다 대 다 관계가 있지만, 물리적인 모델링에서는 다 대 다 관계를 깨야 한다. ==> 1 대 다 관계로 만들어야 한다.

우리는 이를 '제 4 정규화' 관계라고 한다. ==> '다 대 다 관계'를 '일 대 다 관계'로 만드는 것이다.

★ 항상 다 대 다를 일 대 다로 만들려면 중간에 '행위; Action'이 나와야 한다.


        일 대 다                  다 대 일 
고객 ========> 주문  <======== 제품
(부모)                (자식)                   (부모)

항상 부모 테이블의 Primary Key는 자식 테이블의 Foreign Key로 전이가 되어진다.
==> 항상 주문은 우리 고객만(고객ID)만 주문할 수 있으며,
==> 등록되어진 제품(제품코드)만 주문할 수 있다.


------------------------------------------------------
고객ID	주문일자		    제품코드   주문량
------------------------------------------------------
leess / 2021-08-02 AM 11:00:00 / 새우깡     10EA
leess / 2021-08-02 AM 11:00:00 / 감자깡     20EA
leess / 2021-08-02 AM 11:00:00 / 고구마깡  30EA
leess / 2021-08-02 AM 11:00:00 / 쵸코파이  5EA
leess / 2021-08-02 AM 11:00:00 / 양파링     40EA


고객ID와 주문일자는 중복되고 있다.
==> 어떤 테이블의 어떤 컬럼이 중복되고 있으니 분리해서 새로운 테이블을 만들자 ==> 제 1 정규화



[주문]
------------------------------------------------------
전표번호    고객ID	      주문일자
  (P.K)		  
------------------------------------------------------
1              leess     2021-08-02 AM 11:00:00


[주문상세내역]
------------------------------------------------------
제품코드   주문량     전표번호(F.K)
------------------------------------------------------
새우깡     10EA            1
감자깡     20EA            1
고구마깡  30EA            1
쵸코파이  5EA              1
양파링     40EA            1

==> 위의 내용은 해당 전표번호에 대한 상세 내용이다.

==> 한 전표번호에 대해서는 여러개의 주문상세내역이 들어온다.
==> 그러므로 부모 테이블은 '주문', 자식 테이블은 '주문상세내역'이다.



로그인 기능을 추가한다면 고객 테이블에서 고객ID, 비밀번호, 고객명이 Composite index가 된다.

어떤 고객 한명의 로그인정보는 한 개만 들어와야 한다. ( 일 대 일 관계 )

FROM, WHERE을 하면 일단 그 테이블의 한 행 전체를 메모리에 올린다. 그 다음에 SELECT로 화면에 표시할 정보만 거르는 것이다.
==> 그래서 로그인할 때는 고객로그인(고객ID, 비밀번호, 고객명)을 FROM절에 써서 where절을 써도 메모리에 올라가는 것이 적게 한다.

고객 테이블에 있는 회원은 고객로그인에도 반드시 있어야 하며,
또한 고객 테이블에 한 개만 있으니, 고객로그인에도 반드시 한 개만 있어야 한다.
==> 그래서 zero or more이 아니라 exactly one 으로 해야 한다.
==> exactly one ----- exactly one 이 바로 '1 대 1 관계' 이다.


고객은 반드시 주문해야하는 것은 아니며, 딱 한 번만 주문하는 것이 아니라 여러 번 주문할 수 있다. --> zero or more

[ 관계 기호 설명 ]

O : 없을 수 있다.
| : 한 번만 있다.
까치발 : 여러 번 있을 수 있다.


주문에서 주문상세내역으로 가려면 최소한 1번은 있어야 하며, 여러 번 있을 수도 있다.
==> 주문을 했다는 것은 0이 나올 수 없다.

==================================================================

08월 02일 오후수업 

한 학생은 개설되어진 여러 개의 과목을 수강할 수 있으며,
한 개설되어진 과목은 여러 명의 학생을 받을 수 있다.
==> 행위를 만들어서 다 대 다 관계를 끊어준다.
==> 수강신청 테이블을 만든다.


==================================================================

[ 역 정규화 ]

역(거스를 역)
정규화를 위배한다는 말이다.

프로그램상으로 구현하기 어려울 경우에
역정규화를 시도한다.

일반적으로 JOIN 해야할 작업이 많을 경우
이때는 역정규화를 하게 되는 경우가 있다.

주문상세내역에서 제품코드만 나와있는데 
우리가 원하는 정보는 제품명이라고 하자.
이때 JOIN 을 사용하여 조회할 수 있지만
제품 테이블에서 제조일자, 단가는 거의 조회를
안 하고 매번 제품명 컬럼만 조회한다라면 
아예 주문상세내역 테이블에 제품명 컬럼을 넣어준다.
그러면 JOIN 할 필요가 없어진다.

그러면 주문상세내역 테이블은 제 3 정규화를 위배가 된다.

==================================================================


유추할 수 있는 데이터는 반드시 코드화 해야 한다.

유추할 수 없는 데이터는 데이터값 그대로 받도록 한다.

Primary Key는 [속성] - [일반]에서 줄 수 있고,
Unique Key는 [속성] - [인덱스]에서 줄 수 있으며,
Check는 [속성] - [제약 사항]에서 준다.

*) Foreign Key는 관계를 연결하면 알아서 준다.

==================================================================

[ 과제 ] --- 完

COUNTRIES	
DEPARTMENTS
EMPLOYEES
JOBS
JOB_HISTORY	
LOCATIONS	
REGIONS		

위 7 개 테이블을 논리 / 물리 DB 모델링 그리기 

메일제목 :  DB_모델링_박성현_hr.exerd
첨부파일 :  DB_모델링_박성현_hr.exerd.zip
              DB_모델링_박성현_hr.exerd.zip ==> hr.exerd
                                                              +
                                                           논리모드_hr.exerd.png
				            +
                                                           물리모드_hr.exerd.png
==================================================================

※ 미니프로젝트 ==> "도서대여" 관리프로그램 

도서관 

보유 도서( 등록번호 / 도서명 / 저자 / 출판년도 / 출판사 / 장르 / 위치 / 대출여부 )
회원정보 ( 아이디 / 비밀번호 / 전화번호 / 현재 대출한 책 / 대출마감일 / 연장여부 )


한 책이 여러사람에게 대출?(x)
한 책은 한 사람에게 대출된다. (o)

한사람이 여러 책을 대출할 수 있다(O)







※ 내일 : 자바 + 오라클 연결 --> mini 프로젝트(DB는 학원 원격지서버 이용)



