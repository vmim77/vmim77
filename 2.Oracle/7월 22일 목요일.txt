07월 22일 오전수업

[ 상관서브쿼리(=서브상관쿼리) ]

메인쿼리에서 사용되는 테이블에 별칭을 준다.
서브쿼리 조건절에서는 서브쿼리 컬럼과 구분을 주기 위해서 '별칭.컬럼명'으로 쓴다.

메인쿼리에서 사용되는 컬럼이 서브쿼리의 조건절에 사용될 때 상관서브쿼리라고 부른다.

=================================================================================================================================================

[ 서브쿼리로 테이블 만들기 ]

create table 테이블명
as
서브쿼리

==> 테이블 생성

create table tbl_employees_3060
as
select department_id
         , employee_id
         , first_name || ' ' || last_name AS ENAME
         , NVL(salary + (salary * commission_pct), salary) AS MONTHSAL
         , case when substr(jubun, 7, 1) in('1','3') then '남' else '여' end AS GENDER
         , jubun
from employees
where department_id in (30, 60);

==> Table TBL_EMPLOYEES_3060이(가) 생성되었습니다.

=================================================================================================================================================

[ 상관서브쿼리(서브상관쿼리)를 사용한 UPDATE 처리하기 ]

★ 필수로 알아야 할 사항이다.

★ 실무에서 실수로 정보를 삭제하거나, 업데이트를 했을 때가 있을 수 있다.
★ 그래서 delete 또는 update 를 할 땐 먼저 반드시 해당 테이블을 백업해두고 해야한다.

상관서브쿼리를 이용한 UPDATE는 실수하면 복구하기 위한 것이다.
employee_id 는 고유한 키값이다. ( 사원번호는 중복이 없다. )

상관서브쿼리를 이용한 UPDATE를 하려면 기본키가 필요하다.

상관서브쿼리를 이용해서 where 조건절에 임의로 변경된 기본키값과 서브쿼리의 기본키값과 똑같은 것의 값을 변경된 메인쿼리로 넘겨준다.

  set first_name = ( select first_name 
                       from tbl_employees_backup
                       where employee_id = E.employee_id )

=================================================================================================================================================

[ Sub Query 절을 사용하여 데이터를 입력(insert)하기 ]

넣으려는 데이터들의 컬럼의 순서와 있던 테이블의 구조는 똑같아야 한다.

    insert into tbl_employees_3060
    select department_id
         , employee_id
         , first_name || ' ' || last_name AS ENAME
         , NVL(salary + (salary * commission_pct), salary) AS MONTHSAL
         , case when substr(jubun, 7, 1) in('1','3') then '남' else '여' end AS GENDER
         , jubun
    from employees
    where department_id in (40, 50)
    order by 1;


** create, insert 에도 select 문이 쓰일 수 있다.

=================================================================================================================================================

[ Sub Query 절을 사용하여 데이터를 수정(update)하기 ]

update set 에도 select 문이 들어갈 수 있다.

    update tbl_employees_3060
    set monthsal = ( select avg(monthsal)
                     from tbl_employees_3060
                     where department_id = 30 ) --4150
    where department_id = 60;

=================================================================================================================================================

[ Sub Query 절을 사용하여 데이터를 삭제(delete)하기 ]

    delete from tbl_employees_3060
    where monthsal < ( select avg(monthsal) from tbl_employees_3060 ); -- 3800

=================================================================================================================================================

★ create, insert, update, delete 모두 서브쿼리를 사용할 수 있다.
create - as 다음에 써서 원하는 형태를 쓸 수 있다.
insert - 넣으려는 테이블에 구조와 똑같이 select를 만들어서 원하는 값들을 넣을 수 있다.

=================================================================================================================================================

[ JOIN ]

조인은 SQL 입사시험에서 필수로 나온다.

★ 면접질문 : INNER JOIN(내부조인)과 OUTER JOIN(외부조인)의 차이점에 대해 말해보세요.
★ 면접질문 : JOIN과 UNION 의 차이점에 대해 말해보세요.



집합 A = (1, 2, 3)        원소가 3개
집합 B = (a, b)           원소가 2개

집합 A 와 집합 B로 만들 수 있는 모든 경우의 수 = 데카르트곱 3 * 2 = 6
수학에서 말하는 데카르트곱을 데이터베이스에서는 Catersian Product 라고 부른다.


JOIN의 문법은 2개가 있다.
JOIN => SQL 1992 CODE 방식
-> 테이블(뷰) 과 테이블(뷰) 사이에 콤마(,)를 찍어주는 것,
-> 콤마(,)를 찍어주는 것을 제외한 나머지 문법은 데이터베이스 밴더(회사) 제품마다 조금씩 다르다.
( Oracle, MS-SQL 서로 문법이 다르다. )



JOIN => SQL 1999 CODE 방식(ANSI) 
-> 테이블(뷰) 과 테이블(뷰) 사이에 JOIN 이라는 단어를 넣어주는 것.
-> ANSI(표준화) SQL
-> 모든 SQL 의 문법이 똑같은 표준화된 방법이다.


★★★★★ 데이터베이스는 사각형 모양이 떨어져야 한다.
★★★★★ 그래서 그룹함수가 써졌다면, 컬럼이 못 나오는것이다. (group by에 써진 컬럼 제외)
왜냐하면, 그룹함수를 쓰면 행이 1개 밖에 안나오는데, 일반컬럼들의 행의 개수와 다르기 때문이다. 

ex. 

    select employee_id AS 사원번호
        ,  first_name || ' ' || last_name AS 사원명
        ,  department_id AS 부서번호
        ,  salary AS 기본급여
        ,  avg(salary) AS 기본급여평균 -- 이거는 그룹함수여서 행이 1개 밖에 안 나온다.
    from employees;

==> ORA-00937: not a single-group group function 오류 발생!!!!

==> ★ 이럴때 컬럼과 컬럼을 붙혀주면 되는 것이다.




    select *
    from
    ( select employee_id AS 사원번호
          ,  first_name || ' ' || last_name AS 사원명
          ,  department_id AS 부서번호
          ,  salary AS 기본급여
      from employees ) A -- A 는 행이 107개행이다.
    CROSS JOIN 
    ( select trunc( avg(salary) ) AS 기본급여평균
      from employees ) B; -- B 는 행이 1개행이다.


** 콤마(,) / 1992 방식 == CROSS JOIN / 1999 방식(ANSI)


=================================================================================================================================================

[ EQUI JOIN ]

SQL 1992 CODE 방식

    select *
    from employees, departments

그냥 이렇게하면 모든 경우의 수(Catersian Product)가 다 나와서 행이 너무 많아진다.
==> Steven King 의 실제 부서번호는 90인데, 그냥 JOIN 해버리면 Departments 테이블에서 부서번호 10을 쓸데없이 매핑시켜버린다.

---------------------------- EMPLOYEES ------------------------------------------------------------      ----------DEPARTMENTS------------
100   Steven   King   SKING   515.123.4567   03/06/17   AD_PRES   24000   90   6010151234567  ///   10   Administration   200   1700
---------------------------- EMPLOYEES ------------------------------------------------------------      ----------DEPARTMENTS------------


    select *
    from employees E, departments D
    where employees.department_id = departments.department_id;
    -- 별칭으로 안 쓰면 오류가 뜬다 !!!

    select *
    from employees E, departments D
    where E.department_id = D.department_id;
    -- 별칭으로 안 쓰면 오류가 뜬다.
    -- 행이 106개이다, 부서가 미지정(NULL)된 Kimberely Grant가 없다.
    -- EQUI JOIN은 NULL은 다 빼버린다.

==> Kimberely Grant까지 포함시키려고 한다.


-- 1. 일단 EMPLOYEES 테이블을 모두 다 보여줘야 한다. (107명)
-- 2. 그런 다음에 결합시켜줘야 한다. D.department_id(+); 라고 써준다.
-- (+)의 뜻은? 

 (+)는 (+)가 안 붙은 테이블인 E (employees) 의 모든 행을 출력해주고 나서 그 다음에 
 where E.department_id = D.department_id 조건에 만족하는 행들을 보여준다.
 Kimberely Grant는 연결시켜줄 부서가 없기 때문에 departments의 내용은 모두 NULL로 표시한다.
 나머지 사원들은 서로 연결될 departments의 내용들이 있기 때문에 알아서 연결되어 내용이 표시된다.
=================================================================================================================================================

=================================================================================================================================================
=================================================================================================================================================
=================================================================================================================================================
=================================================================================================================================================
=================================================================================================================================================

07월 22일 오후수업


[ INNER JOIN ]

>> SQL 1999 CODE 로 JOIN 해보기

위에 SQL 1992 CODE 방식에서 from의 콤마(,) 를 INNER JOIN으로
WHERE 을 ON 으로 바꾸면 된다.

>> 똑같이 '킴벨리그랜트'는 아직 안 나온다.


>> INNER 는 생략 가능하다.

=================================================================================================================================================


[ OUTER JOIN ]

LEFT OUTER JOIN : 왼쪽꺼는 일단 다 보여주고, 오른쪽 테이블은 연결시켜서 조건에 맞는 것들만 출력한다.
RIGHT OUT JOIN  : 오른쪽꺼는 일단 다 보여주고, 왼쪽 테이블은 연결시켜서 조건에 맞는 것들만 출력한다.
FULL OUT JOIN : 양쪽꺼를 모두 다 보여주고, 조건에 맞는 것들만 출력만한다.

from employees E OUTER LEFT JOIN departments D
==  where E.department_id = D.department_id(+); 

JOIN 글자를 중심으로 LEFT 쪽의 테이블은 일단 다 보여주고, 오른쪽 테이블을 연결시켜서 조건에 맞게 보여준다.

>> OUTER 는 생략 가능하다.

FULL 은 양쪽 테이블을 모두 다 보여준다. (킴벨리그랜트, 120번 이하 부서 모두 출력됨)
그런 다음에 매핑에 들어가서 같은 부서번호끼리 연결한다.

=================================================================================================================================================

** on 절 다음에 where 절이다.

JOIN 절에서 where 조건을 줘서 원하는 자료만 보고 싶다면 바깥 메인쿼리에서 조건을 줘도 답이 나오긴 하지만, JOIN 시킬 절들에서 미리 where 조건으로 걸러서 받는 것을 권장한다.
==> 애초에 메모리 낭비 없이 딱 원하는 것들만 처음부터 올려서 낭비를 없앤다.

ex.

    ( 
        select department_id, employee_id, first_name || ' ' || last_name AS ENAME, salary
        from employees 
        where department_id in (10,30,50)
    ) V1 

---------------------------------------------------------------------------------------------------------------------

    ( 
        select DEPARTMENT_ID
             , TRUNC(avg(salary)) AS DEPT_AVG_SAL
        from employees
        where department_id in (10,30,50)
        group by department_id 
    ) V2 

=================================================================================================================================================

[ NON-EQUI JOIN ]

** EQUI JOIN 과 NON-EQUI JOIN 절은 JOIN 조건절에 들어간다.
** 값은 똑같지 않지만, 어느 범위에 오느냐를 판단하는게 NON-EQUI JOIN 이다.
** = 대신에 between A and B 를 사용한다.

조인해서 어떤 것들을 출력할지 정하는 것이다. 모든 경우의 수를 다 보여주는 것이 아니다.
1992 코드 방식은 where 절에 쓰고, 1999 코드 방식은 on 절에 쓴다.

=================================================================================================================================================

[ SELF JOIN ]

컬럼 네임은 똑같지만 ,나와야할 벨류값이 달라야 할 때 SELF JOIN을 사용한다.

사원번호 / 사원명 / 이메일 / 급여               직속상관번호 / 직속상관명
E_ID         E_NAME   EMAIL   SALARY           E_ID              E_NAME

             자기정보                                          직속상관정보

==> 둘 다 EMPLOYEES 테이블에 있다.


    select E1.employee_id AS 사원번호
    ,E1.first_name || ' ' ||E1.last_name AS 사원명
    ,E1.email AS 이메일
    ,E1.salary AS 기본급여
    ,E2.employee_id AS 직속상관번호
    ,E2.first_name || ' ' || E2.last_name AS 직속상관명
    from employees E1, employees E2
    where E1.manager_id = E2.employee_id -- E1 매니저 번호와 같은 E2의 사원번호의 정보를 합쳐라
    order by 1;


E1 은 나의 정보다 나의 정보에 있는 직속상관 번호를 가지고 가서, 
E2 에 직속상관번호와 똑같은 사원번호를 찾아서 그 정보를 나의 정보 옆에 붙인다.