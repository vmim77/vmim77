07월 27일 오전수업

[ 시노님, Synonym, 동의어 ]

create or replace synonym 동의어 for 원래 이름;

==> 너무 긴 테이블 이름을 동의어로 짧게 만들어서 호출할 때 사용한다.

    select *
    from orauser1.tbl_emp;

    select *
    from emp;

이 둘은 이제 똑같은 결과값을 출력한다. ( orauser1.tbl_emp == emp )

=================================================================================================================================================

[ Constraint, 제약조건 ]

★ 중요

★ 제약조건의 종류는 오라클에서 5개가 존재한다.
1. Primary Key(기본키, 대표식별자) 제약 [P] 
2. Unique 제약 [U]
3. Foregin Key(외래키) 제약 [R]
4. Check 제약 [C]
5. NOT NULL 제약 [C]

=================================================================================================================================================

[ Primary Key ]

★ 하나의 테이블당 오로지 1개만 생성할 수 있다.
★ 어떤 컬럼에 Primary Key(기본키) 제약을 주면 그 컬럼에는 자동적으로 NOT NULL 이 주어지면서 동시에 그 컬럼에는 중복된 값은 들어올 수 없고 오로지 고유한 값만 들어오게 되어진다.


어떤 컬럼의 primary key를 주면 반드시 null이 아닌 값을 가져야 하고, 중복이 아닌 고유한 값을 가져야 한다.



gogekId     varchar2(30)   primary key    ==> COLUMN Level 제약조건
constraint PK_tbl_gogek_gogekId primary key(gogekId)  ==> ROW Level 제약조건   gogekId 컬럼에 primary ket(기본키) 제약을 준것이다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

★ COLUMN 레벨 제약조건보다 ROW 레벨 제약조건을 쓰는 이유? 
==> 편하기는 COLUMN레벨이 편한데 왜 ROW레벨을 쓸까?
==> 유지보수에서는 ROW레벨이 낫다.

[ 제약조건 조회하기 ]
select *
from user_constraints
where table_name = 'TBL_GOGEK';


COLUMN 레벨 제약조건은 제약조건 이름이 'SYS_C007075' 등으로 나와서 알아보기 힘들다.
ROW 레벨 제약조건은 제약조건 이름이 알기 쉽게 나오기 때문에 유지보수하기 쉽다.
ex. PK_TBL_GOGEK_GOGEKID

==> ROW 레벨은 제약조건의 이름을 만들면서 우리가 정할 수 있다.
==> 그래서 둘 다 똑같이 기능이 작동하지만, 유지보수 측면에서 ROW 레벨을 지향한다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

** 제약조건의 이름은 최대 30byte 이다.
** 테이블의 이름도 최대 30byte 이다.
** 컬럼명도 최대 30byte 이다.


=================================================================================================================================================

[ Composite(복합) Primary Key ]

컬럼 1개를 가지고 생성된 Primary Key 를 Single Primary Key 라고 부르고,
컬럼 2개 이상을 가지고 생성된 Primary Key 를 Composite(복합) Primary Key 라고 부른다.
==> 테이블 한 개당 Primary Key는 딱 1개만 있어야 한다.


★ 어떤 테이블의 Primary Key 는 오직 한 개만 생성 가능한데
★ 어떤 컬럼 한 개만 가지고 생성한 Primary Key는 Single Primary Key라고 부르고,
★ 2개 이상의 컬럼을 가지고 생성한 Primary Key는 Composite Primary Key라고 부른다.
★ 복합 기본키는 순서 또한 아주 중요하다 (+index에서 설명할 예정)

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

** primary key를 주면 자동으로 not null도 같이 준다.
** 제약조건의 이름은 오라클 전체에서 고유해야 한다.
** 테이블 이름 또한 고유해야 한다.

그래서 중복을 피하려고, 제약조건의 이름은 '제약조건약자_테이블명_필드명' 으로 만든다.
ex) PK_tbl_gogek_2_gogekId

=================================================================================================================================================

[ Unique ]

후보키, 후보식별자 
==> NULL 허용, 중복X 고유한 값만 가능
★ NOT NULL을 같이써야 후보키의 역할을 제대로 할 수 있다.

기본키처럼 컬럼 레벨로 쓸 수도 있지만, 웬만하면 로우 레벨도 쓰자.

** Primary Key ==> PK
** Unique ==> UQ

Primary Key는 한 테이블 당 한 개만 있어야 하지만, Unique는 한 테이블에 여러 개가 있을 수 있다.

** MS-SQL 이면 UNIQUE를 적용했는데 NULL이 연속으로 들어오면 NULL도 데이터로 취급하여서 중복으로 취급한다.
** 허나, Oracle은 NULL을 데이터로 취급하지 않아서 UNIQUE인데 NULL이 연속으로 들어올 수 있다.
(※ NULL이 여러번 들어와도 중복으로 취급하지 않음)


★ NULL이 아니라면 데이터가 고유해야 한다. 
==> NOT NULL + UNIQUE이면 Primary Key와 똑같다.
★ 허나 UNIQUE는 테이블당 여러 개를 만들 수 있지만, Primary Key는 한 테이블당 1개만 가능하다.

=================================================================================================================================================

[ Composite Unique Key ]

3개를 묶었을 때 고유하기만 하면 된다. (고객ID, 제품ID, 날짜) 

==> Composite Primary Key와 비슷하다.

후보식별자는 예를 들어 회원정보에서 대표식별자인 ID를 까먹었을 때, 고유한 값이면서 NOT NULL일 컬럼들을 다 넣어서 정보를 조회해서 ID를 찾을 때 사용한다.
==> ID를 까먹어서, 이메일을 넣어서 찾아본다.(후보식별자+NOT NULL임)


Unique Key 중에 후보키, 후보식별자가 되려면 해당 컬럼은 NOT NULL 이어야 한다.
==> NULL이면 중복이 가능해져서 어떤 NULL인 것을 찾아야 하는지 알 수 없기 때문이다.

=================================================================================================================================================

[ 제약조건 조회하기 ]

제약조건을 조회할 때는 user_constraints 와 user_cons_columns를 조인해서 본다. ( 제약조건을 보면서, 복합여부를 확인하기 위해서! )

[ 예시 ]
select A.constraint_name, A.constraint_type, A.search_condition, B.column_name, B.position
from user_constraints A JOIN user_cons_columns B
on A.constraint_name = B.constraint_name 
where A.table_name = 'TBL_JUMUN';


※ from user_constraints ==> 제약조건 보기
※ from user_cons_columns ==> 복합 제약조건 보기

=================================================================================================================================================

[  Check 제약 ]

== 유효성 검사
==> 어떤 컬럼에 insert 나 update 할 때 입력되어진 값을 아무거나 하는게 아니라, 조건에 맞는 데이터값만 넣어주는 것이다.

** Check는 CK로 제약조건 이름에 줄임말로 쓴다.

constraint CK_tbl_sawon_jik check(jik in('사장','부장','과장','대리','사원'))
==> jik 컬럼에는 in 안에 값들만 들어올 수 있다.
==> '장군', '소령', '중령' 등이 insert나 update되려 하면 오류가 뜬다.


constraint CK_tbl_sawon_salary check(salary > commission)
==> 월급은 반드시 수당보다 커야한다.
==> 커미션과 같거나 작으면 오류가 뜬다.


NOT NULL, CHECK는 둘다 constraint_type 에서 C로 나온다.

===================================================================================================================================================================================================================================================================================================================================================================================================================================================

07월 27일 오후수업

[ Foreign Key(외래키) 제약 ]

constraint FK_tbl_yeyak_fk_gogekID foreign key(fk_gogekID) references tbl_gogek(gogekid)

** 제약조건 조회에서 Foreign Key의 약칭은 'R'이다.



참조키를 사용할 컬럼은 관례상 앞에 'fk_' 를 붙인다.

★ 반드시 참조를 받는 컬럼(tbl_gogek의 gogekID)는 Primary key 또는 Unique 제약을 가지고 있어야 한다. ==> 값이 고유해야 하기 때문이다.

tbl_yeyak 테이블의 fk_gogekID 컬럼에는 foreign key 제약을 만들었는데
그 뜻은 tbl_yeyak 테이블의 fk_gogekID 컬럼에 입력(insert)되거나 수정(update)되어지는 값은 반드시 tbl_gogek 테이블의 gogekid 컬럼에 존재하는 값들만 가능하다.

즉, tbl_gogek 테이블의 gogekID 컬럼에 존재하지 않는 값은 tbl_yeyak 테이블의 fk_gogekid 컬럼에 들어올 수 없다는 말이다.

그리고 중요한 것은 tbl_gogek 의 gogekid 컬럼은 식별자 컬럼(Primary Key, Unique Key)이어야 한다.


※ 만약 자식테이블에서 쓰고있는 데이터를 부모테이블에서 삭제하려고 한다면 child record found 오류가 뜬다.

==> 우리 회원이 아닌데, 예약을 했다. (모순이 되니깐 성립이 안 됨)
==> 자식테이블에 없는 값은 부모테이블에서 맘대로 삭제해도 된다.


=================================================================================================================================================

[ Foreign Key 생성시  on delete cascade 옵션 부여하기 ]

부모테이블의 값을 제거시, 자식테이블의 값도 동시에 사라진다.
==> 자식테이블에 부모테이블의 값이 있어서 제거를 못하는 것을 해결해준다.
==> 자식테이블에서 먼저 해당 행의 값을 참조해서 쓰는 행을 먼저 지운 다음에, 부모테이블에서 지우려는 행을 지운다.

** 원글을 삭제하면 댓글이 싹 날라가게 할 땐 on delete cascade를 쓰면 된다.
** 나머지의 경우에는 적절치 않으니 절대 on delete cascade 를 쓰며 안 된다.

=================================================================================================================================================

[ Foreign Key 생성시  on delete set null 옵션 부여하기 ]

==> 자식 테이블에서 부모 테이블의 값을 가져다가 쓰는 컬럼의 값을 먼저 null로 바꿔준다.
==> 그 후에 부모테이블에서 데이터를 삭제한다.
==> 이렇게 하기 위해서는 fk_writeno 컬럼은 null 을 허용해야만 한다.
(※ not null로 설정하면 null로 설정해서 참조를 끊을 수 없기 때문에 모순이 일어나 오류다!)


★ foreign key 를 만들 때 옵션이 없는 것과, on delete cascade, on delete set null의 차이점들을 반드시 알아야 한다.

1. 옵션이 없는 것 : 자식테이블의 부모테이블 행의 값을 참조하는 행을 먼저 지운다 => 그 후에 부모테이블의 행을 지운다.
2. on delete cascade : 부모테이블에 있는 행을 지울때 ==> 먼저 자식 테이블의 부모 테이블의 컬럼 값을 먼저 싹 다 지워버린다.(자식테이블의 행도 지워짐) ==> 그 후 부모테이블의 행도 지워진다.
3. on delete set null : 부모테이블에서 어떤 행을 지울때 => 삭제되어질 그 행의 값을 가지고 있는 자식테이블의 행을 null로 바꿔주고 ==> 그 후 부모테이블 행을 지운다.
(★ 대신에 그 컬럼은 반드시 null 을 허용해야 한다.)


=================================================================================================================================================

[ not null 제약 ]

어떤 컬럼의 값을 입력하거나 수정할 때 NULL 을 허락하지 않는다는 말이다.
** not null 제약은 제약조건명을 주고 싶을 땐 컬럼레벨로 줘야 한다.

,saname         varchar2(20)    constraint NN_tbl_jikwon_saname not null  

=================================================================================================================================================

[ 테이블 복사와 제약조건 복사여부 ]

create table tbl_jikwon_copy
as
select *
from tbl_jikwon;

이렇게 제약조건이 있는 테이블을 서브쿼리로 테이블 복사를 하면, 제약조건 중에서 NOT NULL 제약조건만 복사되고, Primary key, unique, foreign key 는 사라진다.

**** 어떤 테이블을 Sub Query 를 사용하여 어떤 테이블을 생성할 경우 원본테이블에 존재하던 제약조건중 NOT NULL 제약만 복사가 되어지고
**** 나머지 제약조건은 복사가 안 됩니다. 또한 복사되는 NOT NULL 제약의 제약조건명은 SYS_C뭐뭐뭐로 변경되어진다.

==> 제약조건을 완벽하게 복사하려면, 복사한 후에 그 복사된 테이블에도 따로 제약조건을 추가해줘야지 완벽한 복사가 된다.
==> 테이블 복사는 데이터와 NOT NULL 제약만 복사한다.